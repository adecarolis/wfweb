<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>wfview</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
    height: 100%; overflow: hidden;
    font-family: system-ui, -apple-system, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: #000; color: #e0e0e0;
    touch-action: manipulation;
    user-select: none; -webkit-user-select: none;
}

#radio {
    display: grid;
    grid-template-rows: 34px 80px 20px 1fr 48px;
    width: 100%; height: 100vh;
    max-width: calc(100vh * 16 / 9);
    margin: 0 auto;
    overflow: hidden;
    background: #0a0a0a;
}

/* ============ ROW 1: TOP BAR ============ */
#topBar {
    display: flex; align-items: center;
    padding: 0 6px; gap: 6px;
    background: #111;
    font-size: 12px;
    border-bottom: 1px solid #282828;
    z-index: 2;
}
#txIndicator {
    display: inline-block;
    padding: 2px 8px; border-radius: 4px;
    font-weight: bold; font-size: 11px;
    border: 1px solid #600;
    background: transparent; color: #600;
    min-width: 28px; text-align: center;
}
#txIndicator.tx {
    background: #c00; color: #fff;
    border-color: #c00;
    animation: txBlink 0.8s infinite;
}
@keyframes txBlink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}
@keyframes tuneBlink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}
#tuneLabel {
    font-size: 11px; font-weight: bold;
    color: #888;
    display: none;
}
#tuneLabel.active {
    display: inline-block;
    color: #c00;
}
#tuneLabel.tuning {
    animation: tuneBlink 0.5s infinite;
}
#modeBtn {
    padding: 3px 14px; border-radius: 5px;
    border: 2px solid #0aa;
    background: transparent; color: #fff;
    cursor: pointer; font-size: 12px;
    font-weight: bold; letter-spacing: 0.5px;
}
#modeBtn:active { background: #0aa; color: #000; }
#pbBars {
    display: inline-flex; align-items: center; gap: 4px;
    height: 16px;
}
#pbBars i {
    display: block; width: 2px; height: 12px;
    background: #888; border-radius: 1px;
}
#filterText { color: #888; font-size: 11px; font-weight: bold; }
.flex-space { flex: 1; }
#clock { color: #888; font-family: 'Courier New', monospace; font-size: 11px; }
#stepLabel { color: #666; font-size: 10px; }
#connDot {
    width: 8px; height: 8px; border-radius: 50%;
    background: #600; flex-shrink: 0;
}
#connDot.connected { background: #0a0; }

/* ============ ROW 2: METER + FREQUENCY ============ */
#meterFreqRow {
    display: flex; align-items: stretch;
    background: #0a0a0a;
    padding: 0 8px;
    gap: 8px;
}
#meterSection {
    flex: 0 0 45%;
    display: flex; align-items: center;
}
#meterCanvas {
    width: 100%; height: 64px;
}
#freqSection {
    flex: 1;
    display: flex; flex-direction: column;
    justify-content: center;
    align-items: flex-end;
    padding-right: 2px;
    min-width: 0;
}
#vfoLine {
    display: flex; align-items: center; gap: 6px;
    font-size: 12px; margin-bottom: 2px;
}
#vfoLabel { color: #aaa; font-weight: bold; }
#vfoNum { color: #888; }
#splitBadge {
    padding: 1px 6px; border-radius: 3px;
    background: #d22; color: #fff;
    font-size: 10px; font-weight: bold;
}
#splitBadge.hidden { display: none; }
#splitFreq { color: #666; font-family: 'Courier New', monospace; font-size: 13px; }
#splitFreq.hidden { display: none; }

#freqDisplay {
    font-family: 'Courier New', 'Lucida Console', monospace;
    font-size: 44px; font-weight: bold;
    color: #fff;
    cursor: pointer;
    white-space: nowrap;
    letter-spacing: 0px;
    line-height: 1;
    font-variant-numeric: tabular-nums;
}
.fdot {
    font-size: 0.55em;
    vertical-align: 0.15em;
    margin: 0 0px;
    color: #ccc;
}

/* ============ ROW 3: SCOPE INFO BAR ============ */
#scopeInfoBar {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    padding: 0 8px;
    background: #0d0d0d;
    font-size: 10px; color: #555;
    border-top: 1px solid #1a1a1a;
    border-bottom: 1px solid #1a1a1a;
    overflow: hidden;
}
#scopeInfoBar span { white-space: nowrap; }
#spanIndicator {
    color: #0cc;
    font-size: 11px;
    font-weight: bold;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 2px;
    justify-self: start;
}
#spanIndicator:hover {
    background: #1a2828;
    color: #0cc;
}
#scopeLabel {
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #444;
    justify-self: center;
}
#otherVfoFreq {
    color: #888;
    font-size: 10px;
    font-family: 'Courier New', monospace;
    justify-self: end;
}

/* ============ ROW 4: SCOPE AREA ============ */
#scopeArea {
    position: relative;
    overflow: hidden;
    background: #000;
}
#spectrumCanvas, #waterfallCanvas {
    display: block; width: 100%;
    position: absolute; left: 0;
    cursor: crosshair;
}
#spectrumCanvas {
    top: 0; height: 35%;
    background: #050510;
}
#waterfallCanvas {
    top: 35%; height: 65%;
    background: #000;
    image-rendering: pixelated;
}
/* Span labels at edges of spectrum */
#spanEdgeLeft, #spanEdgeRight {
    position: absolute; top: 35%;
    transform: translateY(-100%);
    font-size: 9px; color: #666;
    padding: 1px 3px;
    pointer-events: none;
}
#spanEdgeLeft { left: 2px; }
#spanEdgeRight { right: 2px; }

/* ---- Overlays (inside scope area) ---- */
.overlay {
    display: none;
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(8,8,8,0.96);
    z-index: 10;
}
.overlay.visible { display: flex; }

/* Overlay title */
.overlay-title {
    text-align: center;
    font-size: 12px; color: #888;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 8px 0 6px;
}

/* MODE overlay - 3 columns grid */
#modeOverlay.visible {
    flex-direction: column;
    padding: 4px 12px;
}
#modeOverlay .overlay-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px; padding: 4px 0;
    flex: 1; align-content: center;
}

/* BAND overlay - 4 columns grid */
#bandOverlay.visible {
    flex-direction: column;
    padding: 4px 12px;
}
#bandOverlay .overlay-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px; padding: 4px 0;
    flex: 1; align-content: center;
}

/* FUNCTION overlay - 5 columns grid */
#funcOverlay.visible {
    flex-direction: column;
    padding: 4px 8px;
}
#funcOverlay .overlay-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 5px; padding: 4px 0;
    flex: 1; align-content: center;
}

/* AUDIO/MIC overlay */
#audioMicOverlay.visible {
    flex-direction: column;
    padding: 4px 12px;
}
#audioMicOverlay .overlay-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 5px; padding: 4px 0;
    flex: 1; align-content: center;
}

/* SPAN overlay */
#spanOverlay.visible {
    flex-direction: column;
    padding: 4px 12px;
}
#spanOverlay .overlay-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px; padding: 4px 0;
    flex: 1; align-content: center;
}

/* Overlay button */
.ov-btn {
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    min-height: 44px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #222;
    color: #ddd;
    cursor: pointer;
    font-size: 13px; font-weight: bold;
}
.ov-btn:active { background: #444; }
.ov-btn.active {
    border-color: #0aa;
    box-shadow: 0 0 6px rgba(0,170,170,0.3);
}
.ov-btn .btn-label { font-size: 13px; font-weight: bold; }
.ov-btn .btn-state {
    font-size: 10px; font-weight: normal;
    margin-top: 2px;
}
.ov-btn.active .btn-state { color: #0cc; }
.ov-btn:not(.active) .btn-state { color: #666; }
.ov-btn.back-btn {
    border-color: #555;
    color: #888;
    font-size: 18px;
}

/* GAIN overlay */
#gainOverlay.visible {
    flex-direction: column;
    justify-content: center;
    padding: 10px 16px;
    gap: 8px;
}
.gain-row {
    display: flex; align-items: center; gap: 8px;
}
.gain-label {
    font-size: 11px; color: #888; text-transform: uppercase;
    width: 35px; text-align: right; letter-spacing: 1px;
    flex-shrink: 0; font-weight: bold;
}
.gain-bar-bg {
    flex: 1; height: 20px;
    background: #222; border-radius: 2px;
    position: relative; overflow: hidden;
    cursor: pointer;
}
.gain-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #066, #0aa);
    border-radius: 2px;
    transition: width 0.05s linear;
}
.gain-val {
    font-family: 'Courier New', monospace;
    font-size: 12px; width: 40px;
    text-align: right; color: #0aa;
    flex-shrink: 0;
}
/* Hidden range inputs over the gain bars */
.gain-row input[type="range"] {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    opacity: 0; cursor: pointer;
    margin: 0;
}

/* FREQ INPUT overlay */
#freqOverlay.visible {
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 8px;
}
#freqInputDisplay {
    font-family: 'Courier New', monospace;
    font-size: 32px; font-weight: bold;
    color: #fff;
    min-height: 42px;
    text-align: center;
    letter-spacing: 1px;
}
#freqKeypad {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 5px;
    width: 100%;
    max-width: 340px;
}
.key-btn {
    height: 44px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #222;
    color: #ddd;
    cursor: pointer;
    font-size: 16px; font-weight: bold;
}
.key-btn:active { background: #444; }
.key-btn.key-ent {
    border-color: #0aa; color: #0aa;
}

/* ============ ROW 5: BOTTOM BAR ============ */
#bottomBar {
    display: flex;
    padding: 4px 6px;
    gap: 4px;
    background: #111;
    border-top: 1px solid #282828;
    align-items: center;
}
.softBtn {
    flex: 1; height: 38px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #252525;
    color: #ccc;
    cursor: pointer;
    font-size: 12px; font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
.softBtn:active { background: #444; }
.softBtn.active {
    border-color: #0aa;
    color: #0cc;
    background: #1a2828;
}
.softBtn.tx-active {
    border-color: #c00;
    color: #f44;
    background: #281a1a;
}
.softBtn.ptt-btn {
    background: #1a1a1a;
    border-color: #600;
    color: #a44;
}
.softBtn.ptt-btn.tx-active {
    background: #800;
    border-color: #f00;
    color: #fff;
}

/* ============ SPECTRUM WARNINGS ============ */
.spectrum-warning {
    position: absolute;
    top: 4px;
    left: 6px;
    font-size: 11px;
    font-weight: bold;
    color: #c80;
    cursor: pointer;
    z-index: 50;
    padding: 2px 6px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 3px;
    letter-spacing: 0.5px;
    user-select: none;
}
.spectrum-warning:hover {
    color: #fa0;
    background: rgba(0, 0, 0, 0.7);
}
#micOffWarning {
    top: 22px; /* Position below audio warning if both shown */
}

/* ============ RESPONSIVE ============ */
@media (orientation: portrait) {
    #radio {
        max-width: 100%;
        grid-template-rows: 32px 72px 18px 1fr 46px;
    }
    #freqDisplay { font-size: 34px; }
    #meterSection { flex: 0 0 40%; }
    #meterCanvas { height: 54px; }
}
@media (max-height: 450px) {
    #radio { grid-template-rows: 28px 64px 16px 1fr 40px; }
    #freqDisplay { font-size: 34px; }
    #meterCanvas { height: 50px; }
    #bottomBar { padding: 2px 4px; }
    .softBtn { height: 34px; font-size: 11px; }
}
@media (max-width: 480px) {
    #freqDisplay { font-size: 28px; }
    #meterSection { flex: 0 0 35%; }
}
</style>
</head>
<body>
<div id="radio">
    <!-- Row 1: Top bar -->
    <div id="topBar">
        <span id="txIndicator">RX</span>
        <span id="tuneLabel">TUNE</span>
        <button id="modeBtn" onclick="setPanel('mode')">---</button>
        <span id="pbBars"><i></i><i></i></span>
        <span id="filterText">FIL1</span>
        <span class="flex-space"></span>
        <span id="clock">--:--</span>
        <span id="connDot" title="Disconnected"></span>
    </div>

    <!-- Row 2: Meter + Frequency -->
    <div id="meterFreqRow">
        <div id="meterSection">
            <canvas id="meterCanvas" width="500" height="128"></canvas>
        </div>
        <div id="freqSection">
            <div id="vfoLine">
                <span id="vfoLabel">VFO A</span>
                <span id="vfoNum">1</span>
                <span id="splitBadge" class="hidden">SPLIT</span>
                <span id="splitFreq" class="hidden"></span>
            </div>
            <div id="freqDisplay" tabindex="0">---<span class="fdot">.</span>---<span class="fdot">.</span>---</div>
        </div>
    </div>

    <!-- Row 3: Scope info bar -->
    <div id="scopeInfoBar">
        <span id="spanIndicator" onclick="setPanel('span')"></span>
        <span id="scopeLabel">SPECTRUM SCOPE</span>
        <span id="otherVfoFreq">---.---.---</span>
    </div>

    <!-- Row 4: Scope + overlays -->
    <div id="scopeArea">
        <canvas id="spectrumCanvas" width="800" height="150"></canvas>
        <canvas id="waterfallCanvas" width="800" height="200"></canvas>
        <span id="spanEdgeLeft"></span>
        <span id="spanEdgeRight"></span>

        <!-- Mode overlay -->
        <div id="modeOverlay" class="overlay">
            <div class="overlay-title">MODE</div>
            <div class="overlay-grid" id="modeGrid"></div>
        </div>

        <!-- Band overlay -->
        <div id="bandOverlay" class="overlay">
            <div class="overlay-title">BAND STACKING REGISTER</div>
            <div class="overlay-grid" id="bandGrid"></div>
        </div>

        <!-- Function overlay -->
        <div id="funcOverlay" class="overlay">
            <div class="overlay-title">FUNCTION</div>
            <div class="overlay-grid" id="funcGrid"></div>
        </div>

        <!-- Span overlay -->
        <div id="spanOverlay" class="overlay">
            <div class="overlay-title">SPAN</div>
            <div class="overlay-grid" id="spanGrid"></div>
        </div>

        <!-- Gain overlay -->
        <div id="gainOverlay" class="overlay">
            <div class="gain-row">
                <span class="gain-label">AF</span>
                <div class="gain-bar-bg"><div class="gain-bar-fill" id="afGainFill" style="width:50%"></div>
                    <input type="range" id="afGainSlider" min="0" max="255" value="128"></div>
                <span class="gain-val" id="afGainVal">128</span>
            </div>
            <div class="gain-row">
                <span class="gain-label">RF</span>
                <div class="gain-bar-bg"><div class="gain-bar-fill" id="rfGainFill" style="width:50%"></div>
                    <input type="range" id="rfGainSlider" min="0" max="255" value="128"></div>
                <span class="gain-val" id="rfGainVal">128</span>
            </div>
            <div class="gain-row">
                <span class="gain-label">PWR</span>
                <div class="gain-bar-bg"><div class="gain-bar-fill" id="rfPowerFill" style="width:50%"></div>
                    <input type="range" id="rfPowerSlider" min="0" max="255" value="128"></div>
                <span class="gain-val" id="rfPowerVal">128</span>
            </div>
            <div class="gain-row">
                <span class="gain-label">SQL</span>
                <div class="gain-bar-bg"><div class="gain-bar-fill" id="squelchFill" style="width:0%"></div>
                    <input type="range" id="squelchSlider" min="0" max="255" value="0"></div>
                <span class="gain-val" id="squelchVal">0</span>
            </div>
        </div>

        <!-- Freq input overlay -->
        <div id="freqOverlay" class="overlay">
            <div class="overlay-title">F-INP</div>
            <div id="freqInputDisplay">0</div>
            <div id="freqKeypad">
                <button class="key-btn" onclick="freqKey('1')">1</button>
                <button class="key-btn" onclick="freqKey('2')">2</button>
                <button class="key-btn" onclick="freqKey('3')">3</button>
                <button class="key-btn" onclick="freqKey('SPLIT')">SPLIT</button>
                <button class="key-btn" onclick="freqKey('4')">4</button>
                <button class="key-btn" onclick="freqKey('5')">5</button>
                <button class="key-btn" onclick="freqKey('6')">6</button>
                <button class="key-btn" onclick="freqKey('VFO')">VFO</button>
                <button class="key-btn" onclick="freqKey('7')">7</button>
                <button class="key-btn" onclick="freqKey('8')">8</button>
                <button class="key-btn" onclick="freqKey('9')">9</button>
                <button class="key-btn key-ent" onclick="freqKey('ENT')">ENT</button>
                <button class="key-btn" onclick="freqKey('.')">&#x00B7;</button>
                <button class="key-btn" onclick="freqKey('0')">0</button>
                <button class="key-btn" onclick="freqKey('CE')">CE</button>
                <button class="key-btn ov-btn back-btn" onclick="freqKey('BACK')">&#x21A9;</button>
            </div>
        </div>

        <!-- Audio/Mic enable menu -->
        <div id="audioMicOverlay" class="overlay">
            <div class="overlay-title">AUDIO / TX</div>
            <div class="overlay-grid" id="audioMicGrid"></div>
        </div>

        <!-- Warning overlays on spectrum -->
        <div id="audioOffWarning" class="spectrum-warning" onclick="showAudioMicMenu()" style="display: none;">AUDIO OFF</div>
        <div id="micOffWarning" class="spectrum-warning" onclick="showAudioMicMenu()" style="display: none;">MIC OFF</div>
    </div>

    <!-- Row 5: Bottom bar -->
    <div id="bottomBar"></div>
</div>

<script>
// ============================================================
// STATE
// ============================================================
var ws = null;
var currentFreq = 0;
var vfoAFreq = 0;
var vfoBFreq = 0;
var currentMode = '';
var tuneStep = 1000;
var isTransmitting = false;
var isSplit = false;
var reconnectTimer = null;
var defaultModes = ['LSB', 'USB', 'AM', 'CW', 'RTTY', 'FM', 'CW-R', 'RTTY-R'];

var audioCtx = null;
var audioWorkletNode = null;
var audioEnabled = false;
var audioAvailable = false;
var audioSampleRate = 48000;

var micEnabled = false;
var txAudioAvailable = false;
var micStream = null;
var micAudioCtx = null;
var micWorkletNode = null;
var micSeq = 0;

var nbOn = false;
var nrOn = false;
var anfOn = false;
var tunerState = 0;
var currentPreamp = 0;
var currentFilter = 1;

var availableSpans = [];
var currentSpanIndex = -1;

var hasSpectrum = false;
var spectAmpMax = 160;
var spectStartFreq = 0;
var spectEndFreq = 0;
var spectData = null;
var spectDataLen = 0;
var wfImageData = null;
var wfOffCanvas = null;
var wfOffCtx = null;
var spectRenderPending = false;
var colorTable = null;

// UI state
var currentPanel = 'default';
var availableModes = defaultModes.slice();
var availablePreamps = [];
var availableFilters = [];
var currentVfo = 'A';

// Meter state
var meterVal = -54;
var powerVal = 0;
var swrVal = 1.0;

// Freq input
var freqInputBuf = '';

// ============================================================
// WEBSOCKET (preserved)
// ============================================================
function connect() {
    var wsUrl;
    if (location.protocol === 'https:') {
        wsUrl = 'wss://' + location.hostname + ':' + (location.port || '443');
    } else {
        var wsPort = parseInt(location.port || '80') + 1;
        wsUrl = 'ws://' + location.hostname + ':' + wsPort;
    }
    ws = new WebSocket(wsUrl);
    ws.binaryType = 'arraybuffer';

    ws.onopen = function() {
        document.getElementById('connDot').classList.add('connected');
        document.getElementById('connDot').title = 'Connected';
        if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
        send({ cmd: 'getStatus' });
    };
    ws.onclose = function() {
        document.getElementById('connDot').classList.remove('connected');
        document.getElementById('connDot').title = 'Disconnected';
        if (micEnabled) stopMic();
        if (audioEnabled) stopAudio();
        audioAvailable = false;
        txAudioAvailable = false;
        updateWarningVisibility();
        scheduleReconnect();
    };
    ws.onerror = function() {};
    ws.onmessage = function(event) {
        if (event.data instanceof ArrayBuffer) { handleBinaryMessage(event.data); return; }
        try { handleMessage(JSON.parse(event.data)); } catch(e) { console.error('Parse error:', e); }
    };
}

function scheduleReconnect() {
    if (!reconnectTimer) {
        reconnectTimer = setTimeout(function() { reconnectTimer = null; connect(); }, 3000);
    }
}

function send(obj) {
    if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(obj));
}

// ============================================================
// MESSAGE HANDLING
// ============================================================
function handleMessage(msg) {
    switch (msg.type) {
        case 'rigInfo':
            if (msg.connected) {
                if (msg.modes) populateModes(msg.modes);
                if (msg.hasSpectrum) { hasSpectrum = true; spectAmpMax = msg.spectAmpMax || 160; }
                if (msg.audioAvailable) { audioAvailable = true; audioSampleRate = msg.audioSampleRate || 48000; }
                updateTxAudioAvailable(msg.txAudioAvailable || false);
                if (msg.spans) populateSpans(msg.spans);
                if (msg.preamps) populatePreamps(msg.preamps);
                if (msg.filters) populateFilters(msg.filters);
                updateWarningVisibility();
            }
            break;
        case 'rigConnected':
            if (msg.modes) populateModes(msg.modes);
            if (msg.hasSpectrum) { hasSpectrum = true; spectAmpMax = msg.spectAmpMax || 160; }
            if (msg.audioAvailable) { audioAvailable = true; audioSampleRate = msg.audioSampleRate || 48000; }
            updateTxAudioAvailable(msg.txAudioAvailable || false);
            if (msg.spans) populateSpans(msg.spans);
            if (msg.preamps) populatePreamps(msg.preamps);
            if (msg.filters) populateFilters(msg.filters);
            updateWarningVisibility();
            break;
        case 'audioAvailable':
            if (msg.available) { audioAvailable = true; audioSampleRate = msg.sampleRate || 48000; }
            else { audioAvailable = false; if (audioEnabled) stopAudio(); }
            if (msg.txAudioAvailable !== undefined) updateTxAudioAvailable(msg.txAudioAvailable);
            updateWarningVisibility();
            break;
        case 'audioStatus':
            if (msg.enabled) { audioEnabled = true; audioSampleRate = msg.sampleRate || audioSampleRate; }
            else { audioEnabled = false; }
            renderBottomBar();
            updateWarningVisibility();
            if (currentPanel === 'audiomiс') renderAudioMicOverlay();
            break;
        case 'status':
            // Handle VFO-specific frequencies if available
            if (msg.vfoAFrequency !== undefined) vfoAFreq = msg.vfoAFrequency;
            if (msg.vfoBFrequency !== undefined) vfoBFreq = msg.vfoBFrequency;
            // Update display after VFO frequencies are set
            if (msg.vfoAFrequency !== undefined || msg.vfoBFrequency !== undefined) {
                // Determine current VFO frequency for main display
                if (currentVfo === 'A' && msg.vfoAFrequency !== undefined) {
                    updateFrequency(msg.vfoAFrequency);
                } else if (currentVfo === 'B' && msg.vfoBFrequency !== undefined) {
                    updateFrequency(msg.vfoBFrequency);
                } else if (msg.frequency !== undefined) {
                    updateFrequency(msg.frequency);
                }
                updateOtherVfoDisplay();
            } else if (msg.frequency !== undefined) {
                updateFrequency(msg.frequency);
            }
            if (msg.mode !== undefined) updateMode(msg.mode);
            if (msg.filter !== undefined) updateFilterBtn(msg.filter);
            if (msg.sMeter !== undefined) updateSMeter(msg.sMeter);
            if (msg.transmitting !== undefined) updateTxStatus(msg.transmitting);
            if (msg.afGain !== undefined) updateSlider('afGain', msg.afGain);
            if (msg.rfGain !== undefined) updateSlider('rfGain', msg.rfGain);
            if (msg.rfPower !== undefined) updateSlider('rfPower', msg.rfPower);
            if (msg.squelch !== undefined) updateSlider('squelch', msg.squelch);
            if (msg.split !== undefined) updateSplit(msg.split);
            if (msg.spanIndex !== undefined) updateSpanIndex(msg.spanIndex);
            if (msg.nb !== undefined) updateToggle('nb', msg.nb);
            if (msg.nr !== undefined) updateToggle('nr', msg.nr);
            if (msg.autoNotch !== undefined) updateToggle('anf', msg.autoNotch);
            if (msg.tuner !== undefined) updateTunerState(msg.tuner);
            if (msg.preamp !== undefined) updatePreampBtn(msg.preamp);
            if (msg.filterWidth !== undefined) updateSlider('filterWidth', msg.filterWidth);
            break;
        case 'update':
            // Handle VFO-specific frequencies if available
            if (msg.vfoAFrequency !== undefined) vfoAFreq = msg.vfoAFrequency;
            if (msg.vfoBFrequency !== undefined) vfoBFreq = msg.vfoBFrequency;
            // Update display after VFO frequencies are set
            if (msg.vfoAFrequency !== undefined || msg.vfoBFrequency !== undefined) {
                // Determine current VFO frequency for main display
                if (currentVfo === 'A' && msg.vfoAFrequency !== undefined) {
                    updateFrequency(msg.vfoAFrequency);
                } else if (currentVfo === 'B' && msg.vfoBFrequency !== undefined) {
                    updateFrequency(msg.vfoBFrequency);
                } else if (msg.frequency !== undefined) {
                    updateFrequency(msg.frequency);
                }
                updateOtherVfoDisplay();
            } else if (msg.frequency !== undefined) {
                updateFrequency(msg.frequency);
            }
            if (msg.mode !== undefined) updateMode(msg.mode);
            if (msg.filter !== undefined) updateFilterBtn(msg.filter);
            if (msg.sMeter !== undefined) updateSMeter(msg.sMeter);
            if (msg.powerMeter !== undefined) updatePowerMeter(msg.powerMeter);
            if (msg.swrMeter !== undefined) updateSwrMeter(msg.swrMeter);
            if (msg.transmitting !== undefined) updateTxStatus(msg.transmitting);
            if (msg.afGain !== undefined) updateSlider('afGain', msg.afGain);
            if (msg.rfGain !== undefined) updateSlider('rfGain', msg.rfGain);
            if (msg.rfPower !== undefined) updateSlider('rfPower', msg.rfPower);
            if (msg.squelch !== undefined) updateSlider('squelch', msg.squelch);
            if (msg.split !== undefined) updateSplit(msg.split);
            if (msg.spanIndex !== undefined) updateSpanIndex(msg.spanIndex);
            if (msg.nb !== undefined) updateToggle('nb', msg.nb);
            if (msg.nr !== undefined) updateToggle('nr', msg.nr);
            if (msg.autoNotch !== undefined) updateToggle('anf', msg.autoNotch);
            if (msg.tuner !== undefined) updateTunerState(msg.tuner);
            if (msg.preamp !== undefined) updatePreampBtn(msg.preamp);
            if (msg.filterWidth !== undefined) updateSlider('filterWidth', msg.filterWidth);
            break;
        case 'meters':
            if (msg.sMeter !== undefined) updateSMeter(msg.sMeter);
            if (msg.powerMeter !== undefined) updatePowerMeter(msg.powerMeter);
            if (msg.swrMeter !== undefined) updateSwrMeter(msg.swrMeter);
            break;
        case 'error':
            console.error('Server error:', msg.message);
            break;
    }
}

// ============================================================
// UI UPDATES
// ============================================================
function updateFrequency(hz) {
    currentFreq = hz;

    // Store frequency for current VFO only
    if (currentVfo === 'A') {
        vfoAFreq = hz;
    } else {
        vfoBFreq = hz;
    }

    // Update main frequency display
    var mhz = Math.floor(hz / 1000000);
    var khz = Math.floor((hz % 1000000) / 1000);
    var hzPart = hz % 1000;
    var d = document.getElementById('freqDisplay');
    d.innerHTML =
        String(mhz).padStart(3, '\u2007') +
        '<span class="fdot">.</span>' +
        String(khz).padStart(3, '0') +
        '<span class="fdot">.</span>' +
        String(hzPart).padStart(3, '0');

    // Update other VFO frequency display
    updateOtherVfoDisplay();
}

function updateOtherVfoDisplay() {
    var otherFreq = (currentVfo === 'A') ? vfoBFreq : vfoAFreq;
    if (otherFreq > 0) {
        var mhz = Math.floor(otherFreq / 1000000);
        var khz = Math.floor((otherFreq % 1000000) / 1000);
        var hz = otherFreq % 1000;
        var displayText = mhz + '.' + String(khz).padStart(3, '0') + '.' + String(hz).padStart(3, '0');
        document.getElementById('otherVfoFreq').textContent = displayText;
    } else {
        document.getElementById('otherVfoFreq').textContent = '---.---.---';
    }
}

function updateMode(mode) {
    currentMode = mode;
    document.getElementById('modeBtn').textContent = mode;
    if (currentPanel === 'mode') renderModeOverlay();
}

function updateFilterBtn(num) {
    currentFilter = num;
    document.getElementById('filterText').textContent = 'FIL' + num;
}

function updateTxStatus(tx) {
    isTransmitting = tx;
    var ind = document.getElementById('txIndicator');
    ind.textContent = tx ? 'TX' : 'RX';
    ind.classList.toggle('tx', tx);
    drawMeter();
    renderBottomBar();
}

function updateSplit(on) {
    isSplit = on;
    document.getElementById('splitBadge').classList.toggle('hidden', !on);
}

function updateToggle(name, state) {
    if (name === 'nb') nbOn = !!state;
    else if (name === 'nr') nrOn = !!state;
    else if (name === 'anf') anfOn = !!state;
    updateDspIndicators();
    if (currentPanel === 'func') renderFuncOverlay();
}

function updateTunerState(val) {
    tunerState = val;
    var lbl = document.getElementById('tuneLabel');
    lbl.classList.toggle('active', val > 0);
    lbl.classList.toggle('tuning', val === 2);
    if (currentPanel === 'func') renderFuncOverlay();
}

function updatePreampBtn(num) {
    currentPreamp = num;
    if (currentPanel === 'func') renderFuncOverlay();
}

function updateDspIndicators() {
    var el = document.getElementById('dspIndicators');
    var tags = [];
    if (nbOn) tags.push('NB');
    if (nrOn) tags.push('NR');
    if (anfOn) tags.push('ANF');
    el.innerHTML = tags.map(function(t) { return '<span class="dsp-tag">' + t + '</span>'; }).join('');
}

// Slider system
var sliderSetTimes = {};
var sliderDragging = {};
var SLIDER_DEBOUNCE_MS = 1500;

function initSliderTracking() {
    ['afGain', 'rfGain', 'rfPower', 'squelch'].forEach(function(name) {
        var slider = document.getElementById(name + 'Slider');
        if (!slider) return;
        slider.addEventListener('mousedown', function() { sliderDragging[name] = true; });
        slider.addEventListener('touchstart', function() { sliderDragging[name] = true; });
        slider.addEventListener('mouseup', function() { sliderDragging[name] = false; });
        slider.addEventListener('touchend', function() { sliderDragging[name] = false; });
        slider.addEventListener('mouseleave', function() { sliderDragging[name] = false; });
        slider.addEventListener('touchcancel', function() { sliderDragging[name] = false; });
        slider.addEventListener('input', function() {
            var val = slider.value;
            sliderSetTimes[name] = Date.now();
            document.getElementById(name + 'Val').textContent = val;
            var fill = document.getElementById(name.replace(/([A-Z])/g, function(m) { return m; }) + 'Fill');
            if (fill) fill.style.width = (val / 255 * 100) + '%';
            if (name === 'afGain') throttledSend('afGain', 'setAfGain', val);
            else if (name === 'rfGain') throttledSend('rfGain', 'setRfGain', val);
            else if (name === 'rfPower') throttledSend('rfPower', 'setRfPower', val);
            else if (name === 'squelch') throttledSend('squelch', 'setSquelch', val);
        });
    });
}

function updateSlider(name, val) {
    if (sliderDragging[name]) return;
    if ((Date.now() - (sliderSetTimes[name] || 0)) < SLIDER_DEBOUNCE_MS) return;
    var slider = document.getElementById(name + 'Slider');
    var valSpan = document.getElementById(name + 'Val');
    if (slider) slider.value = val;
    if (valSpan) valSpan.textContent = val;
    // Update fill bars
    var fillId = name + 'Fill';
    var fill = document.getElementById(fillId);
    if (fill) fill.style.width = (val / 255 * 100) + '%';
}

var sliderTimers = {};
function throttledSend(name, cmd, val) {
    if (sliderTimers[name]) clearTimeout(sliderTimers[name]);
    sliderTimers[name] = setTimeout(function() { send({ cmd: cmd, value: parseInt(val) }); }, 50);
}

function populateModes(modes) { availableModes = modes; if (currentPanel === 'mode') renderModeOverlay(); }
function populateSpans(spans) { availableSpans = spans; }
function populatePreamps(preamps) { availablePreamps = preamps || []; }
function populateFilters(filters) { availableFilters = filters || []; }
function updateSpanIndex(idx) {
    currentSpanIndex = idx;
    if (currentPanel === 'span') renderSpanOverlay();
    // Update span indicator
    var spanText = 'SPAN';
    if (idx >= 0 && idx < availableSpans.length) {
        spanText = availableSpans[idx].name;
    }
    document.getElementById('spanIndicator').textContent = spanText;
}

// ============================================================
// CANVAS S-METER (IC-7300 segmented style)
// ============================================================
// IC-7300 S-meter constants
// Segment layout: 21 segs for S0-S9, 14 segs for S9+ (total 35)
var METER_SEGS = 35;
var METER_S9_SEG = 21;
// IC-7300 colors
var METER_BLUE = '#4488cc';     // segments below S9
var METER_RED  = '#cc2222';     // segments above S9
var METER_DARK = '#1c1c1c';     // inactive segment
var METER_BASELINE = '#999';    // thin white line under segments

function updateSMeter(val) { meterVal = val; if (!isTransmitting) drawMeter(); }
function updatePowerMeter(val) { powerVal = val; if (isTransmitting) drawMeter(); }
function updateSwrMeter(val) { swrVal = val; if (isTransmitting) drawMeter(); }

function drawMeter() {
    var canvas = document.getElementById('meterCanvas');
    var dpr = window.devicePixelRatio || 1;
    var cssW = canvas.clientWidth;
    var cssH = canvas.clientHeight;
    if (cssW === 0) return;

    if (canvas.width !== Math.round(cssW * dpr) || canvas.height !== Math.round(cssH * dpr)) {
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
    }
    var ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, cssW, cssH);
    var cw = cssW, ch = cssH;

    // --- Shared geometry ---
    // "S/SWR" label on the left takes ~30px
    var labelW = 30;
    var barX = labelW + 2;                     // where segments start
    var barW = cw - barX - 2;                  // total width for segments
    var segGap = Math.max(1, Math.round(barW * 0.004));
    var segW  = (barW - (METER_SEGS - 1) * segGap) / METER_SEGS;
    if (segW < 2) { segW = 2; segGap = 1; }

    // Helper: x position of segment n
    function segX(n) { return barX + n * (segW + segGap); }

    if (!isTransmitting) {
        drawSMeter(ctx, cw, ch, barX, barW, segW, segGap, segX, labelW);
    } else {
        drawTxMeters(ctx, cw, ch, barX, barW, segW, segGap, segX, labelW);
    }

    ctx.setTransform(1, 0, 0, 1, 0, 0);
}

function drawSMeter(ctx, cw, ch, barX, barW, segW, segGap, segX, labelW) {
    // Layout: scale row at top, tick marks, segments, white baseline, value text
    var scaleY  = 1;       // top of scale numbers
    var tickY   = 14;      // tick mark top
    var tickH   = 3;
    var segY    = 20;      // top of segment bar
    var segH    = ch - segY - 14;  // leave room for value text at bottom
    if (segH < 10) segH = 10;
    var baseY   = segY + segH;     // white baseline

    // --- "S/SWR" label (left side, two lines) ---
    ctx.fillStyle = '#888';
    ctx.font = '9px system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText('S', 2, scaleY);
    ctx.fillStyle = '#666';
    ctx.fillText('SWR', 2, scaleY + 11);

    // --- Scale labels (above segments) ---
    // S-unit labels: 1, 3, 5, 7, 9 – positioned at their segment
    // Each S-unit = METER_S9_SEG/9 segments
    var sPerUnit = METER_S9_SEG / 9;
    var sLabels = [
        { text: '1', seg: 1 * sPerUnit },
        { text: '3', seg: 3 * sPerUnit },
        { text: '5', seg: 5 * sPerUnit },
        { text: '7', seg: 7 * sPerUnit },
        { text: '9', seg: 9 * sPerUnit }
    ];
    ctx.font = 'bold 9px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#ccc';
    for (var i = 0; i < sLabels.length; i++) {
        var lx = segX(Math.round(sLabels[i].seg));
        ctx.fillText(sLabels[i].text, lx, scaleY);
    }

    // +dB labels in red: +20, +40, +60dB
    var dbPerSeg = 60 / (METER_SEGS - METER_S9_SEG);  // dB per segment in S9+ zone
    var dbLabels = [
        { text: '+20', seg: METER_S9_SEG + Math.round(20 / dbPerSeg) },
        { text: '+40', seg: METER_S9_SEG + Math.round(40 / dbPerSeg) },
        { text: '+60dB', seg: METER_SEGS - 1 }
    ];
    ctx.fillStyle = '#cc4444';
    for (var j = 0; j < dbLabels.length; j++) {
        var dx = segX(Math.round(dbLabels[j].seg));
        ctx.fillText(dbLabels[j].text, dx, scaleY);
    }

    // --- Tick marks (small vertical lines below scale numbers) ---
    ctx.fillStyle = '#666';
    // Ticks at every S-unit position (1-9)
    for (var t = 1; t <= 9; t++) {
        var tx = segX(Math.round(t * sPerUnit));
        ctx.fillRect(Math.round(tx) - 0.5, tickY, 1, tickH);
    }
    // Ticks at +20, +40, +60
    for (var dt = 0; dt < dbLabels.length; dt++) {
        var dtx = segX(Math.round(dbLabels[dt].seg));
        ctx.fillStyle = '#884444';
        ctx.fillRect(Math.round(dtx) - 0.5, tickY, 1, tickH);
    }
    // Small dots between major ticks (every other segment)
    ctx.fillStyle = '#333';
    for (var dot = 0; dot < METER_SEGS; dot += 2) {
        var dotx = segX(dot) + segW / 2;
        ctx.fillRect(Math.round(dotx), tickY + 1, 1, 1);
    }

    // --- Calculate fill level ---
    var fillCount = 0;
    if (meterVal <= 0) {
        // -54 (S0) → 0 segs, 0 (S9) → METER_S9_SEG segs
        fillCount = Math.round(((meterVal + 54) / 54) * METER_S9_SEG);
    } else {
        // 0 (S9) → S9_SEG, 60 (S9+60) → METER_SEGS
        fillCount = METER_S9_SEG + Math.round(Math.min(60, meterVal) / 60 * (METER_SEGS - METER_S9_SEG));
    }
    fillCount = Math.max(0, Math.min(METER_SEGS, fillCount));

    // --- Draw segment bar ---
    for (var s = 0; s < METER_SEGS; s++) {
        var sx = segX(s);
        if (s < fillCount) {
            ctx.fillStyle = (s < METER_S9_SEG) ? METER_BLUE : METER_RED;
        } else {
            ctx.fillStyle = METER_DARK;
        }
        ctx.fillRect(sx, segY, segW, segH);
    }

    // --- White baseline under segments (IC-7300 distinctive feature) ---
    ctx.fillStyle = METER_BASELINE;
    ctx.fillRect(barX, baseY, barW, 1);

    // --- S-value readout (bottom-left) ---
    var label;
    if (meterVal <= 0) {
        var sUnit = Math.max(0, (meterVal + 54) / 6);
        label = sUnit >= 9 ? 'S9' : 'S' + Math.floor(Math.min(9, sUnit));
    } else {
        label = 'S9+' + Math.round(meterVal) + 'dB';
    }
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';
    ctx.fillText(label, 2, ch - 1);
}

function drawTxMeters(ctx, cw, ch, barX, barW, segW, segGap, segX, labelW) {
    // TX mode: S/Po bar on top, SWR bar on bottom (matching IC-7300 "S/Po" display)
    var gap = 4;
    var meterH = Math.floor((ch - gap) / 2);

    // === Po meter (top half) ===
    drawSegBar(ctx, {
        x: barX, y: 0, w: barW, h: meterH,
        label: 'Po', labelX: 2,
        scaleLabels: [
            { text: '0', frac: 0 },
            { text: '25', frac: 0.25 },
            { text: '50', frac: 0.50 },
            { text: '100%', frac: 1.0 }
        ],
        fillFrac: Math.min(1, powerVal / 100),
        fillColor: METER_BLUE,
        warnColor: METER_RED,
        warnFrac: 1.0,  // no warning zone for Po
        valueText: Math.round(powerVal) + 'W',
        segW: segW, segGap: segGap, segX: segX
    });

    // === SWR meter (bottom half) ===
    var swrY = meterH + gap;
    // SWR scale is non-linear: 1.0-1.5-2-3 compressed on left
    var swrFrac = Math.min(1, Math.max(0, (swrVal - 1.0) / 5.0));
    drawSegBar(ctx, {
        x: barX, y: swrY, w: barW, h: meterH,
        label: 'SWR', labelX: 2,
        scaleLabels: [
            { text: '1', frac: 0 },
            { text: '1.5', frac: 0.1 },
            { text: '2', frac: 0.2 },
            { text: '3', frac: 0.4 }
        ],
        fillFrac: swrFrac,
        fillColor: METER_BLUE,
        warnColor: METER_RED,
        warnFrac: 0.2,  // SWR > 2.0 → red
        valueText: swrVal.toFixed(1),
        segW: segW, segGap: segGap, segX: segX
    });
}

// Generic segmented meter bar (used for Po, SWR in TX mode)
function drawSegBar(ctx, o) {
    var scaleY = o.y + 1;
    var segY = o.y + 14;
    var segH = o.h - 16;
    if (segH < 6) segH = 6;
    var baseY = segY + segH;

    // Label
    ctx.fillStyle = '#888';
    ctx.font = 'bold 9px system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(o.label, o.labelX, scaleY);

    // Scale labels
    ctx.fillStyle = '#888';
    ctx.font = '8px system-ui, sans-serif';
    ctx.textAlign = 'center';
    for (var i = 0; i < o.scaleLabels.length; i++) {
        var sl = o.scaleLabels[i];
        var lx = o.segX(Math.round(sl.frac * (METER_SEGS - 1)));
        ctx.fillText(sl.text, lx, scaleY);
    }

    // Value text (right side)
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    ctx.fillText(o.valueText, o.x + o.w, scaleY);

    // Segments
    var fillCount = Math.round(o.fillFrac * METER_SEGS);
    fillCount = Math.max(0, Math.min(METER_SEGS, fillCount));
    var warnSeg = Math.round(o.warnFrac * METER_SEGS);

    for (var s = 0; s < METER_SEGS; s++) {
        var sx = o.segX(s);
        if (s < fillCount) {
            ctx.fillStyle = (s >= warnSeg) ? o.warnColor : o.fillColor;
        } else {
            ctx.fillStyle = METER_DARK;
        }
        ctx.fillRect(sx, segY, o.segW, segH);
    }

    // White baseline
    ctx.fillStyle = METER_BASELINE;
    ctx.fillRect(o.x, baseY, o.w, 1);
}

// ============================================================
// BOTTOM BAR + PANEL SYSTEM
// ============================================================

function setPanel(name) {
    hideAllOverlays();
    currentPanel = name;
    // Show relevant overlay
    if (name === 'mode') renderModeOverlay();
    else if (name === 'band') renderBandOverlay();
    else if (name === 'func') renderFuncOverlay();
    else if (name === 'audiomiс') renderAudioMicOverlay();
    else if (name === 'gain') document.getElementById('gainOverlay').classList.add('visible');
    else if (name === 'scope') {}
    else if (name === 'span') renderSpanOverlay();
    else if (name === 'freqinp') renderFreqInput();
    renderBottomBar();
}

function hideAllOverlays() {
    var overlays = document.querySelectorAll('.overlay');
    for (var i = 0; i < overlays.length; i++) overlays[i].classList.remove('visible');
}

function renderBottomBar() {
    var bar = document.getElementById('bottomBar');
    bar.innerHTML = '';
    var btns = getBottomButtons();
    for (var i = 0; i < btns.length; i++) {
        var b = btns[i];
        var el = document.createElement('button');
        el.className = 'softBtn';
        if (b.active) el.classList.add('active');
        if (b.txActive) el.classList.add('tx-active');
        if (b.cls) el.classList.add(b.cls);
        el.textContent = b.label;
        if (b.action) el.onclick = b.action;
        bar.appendChild(el);
    }
}

function getBottomButtons() {
    switch (currentPanel) {
        case 'default':
            return [
                { label: 'MODE', action: function() { setPanel('mode'); } },
                { label: 'BAND', action: function() { setPanel('band'); } },
                { label: 'FUNC', action: function() { setPanel('func'); } },
                { label: 'GAIN', action: function() { setPanel('gain'); } },
                { label: 'PTT', txActive: isTransmitting, cls: 'ptt-btn', action: function() { handlePTTPress(); } }
            ];
        case 'mode':
        case 'band':
        case 'func':
        case 'audiomiс':
        case 'span':
        case 'freqinp':
            return [
                { label: '\u23CE', action: function() { setPanel('default'); } }
            ];
        case 'gain':
            return [
                { label: 'VFO A', active: currentVfo === 'A', action: function() { selectVFO('A'); } },
                { label: 'VFO B', active: currentVfo === 'B', action: function() { selectVFO('B'); } },
                { label: 'A/B', action: function() { swapVFO(); } },
                { label: 'SPLIT', active: isSplit, action: function() { toggleSplit(); } },
                { label: '\u23CE', action: function() { hideAllOverlays(); setPanel('default'); } }
            ];
        case 'scope': {
            var b = [];
            if (availableSpans.length > 0) {
                var sl = 'SPAN';
                if (currentSpanIndex >= 0 && currentSpanIndex < availableSpans.length)
                    sl = availableSpans[currentSpanIndex].name;
                b.push({ label: sl, action: function() { setPanel('span'); } });
            }
            b.push({ label: 'AUDIO', active: audioEnabled, action: function() { toggleAudio(); renderBottomBar(); } });
            if (txAudioAvailable && window.isSecureContext) {
                b.push({ label: 'MIC', active: micEnabled, action: function() { toggleMic(); renderBottomBar(); } });
            }
            b.push({ label: 'PTT', txActive: isTransmitting, cls: 'ptt-btn', action: null });
            b.push({ label: '\u23CE', action: function() { setPanel('default'); } });
            return b;
        }
        default:
            return [{ label: '\u23CE', action: function() { setPanel('default'); } }];
    }
}

// --- Overlay renderers ---

function renderModeOverlay() {
    var grid = document.getElementById('modeGrid');
    grid.innerHTML = '';
    for (var i = 0; i < availableModes.length; i++) {
        var btn = document.createElement('button');
        btn.className = 'ov-btn' + (availableModes[i] === currentMode ? ' active' : '');
        btn.textContent = availableModes[i];
        btn.onclick = (function(m) { return function() { setMode(m); setPanel('default'); }; })(availableModes[i]);
        grid.appendChild(btn);
    }
    // Back button
    var back = document.createElement('button');
    back.className = 'ov-btn back-btn';
    back.innerHTML = '&#x21A9;';
    back.onclick = function() { setPanel('default'); };
    grid.appendChild(back);
    document.getElementById('modeOverlay').classList.add('visible');
}

function renderBandOverlay() {
    var grid = document.getElementById('bandGrid');
    grid.innerHTML = '';
    var bands = [
        { label: '1.8', freq: 1800000 },
        { label: '3.5', freq: 3500000 },
        { label: '7', freq: 7000000 },
        { label: 'F-INP', action: 'freqinp' },
        { label: '10', freq: 10100000 },
        { label: '14', freq: 14000000 },
        { label: '18', freq: 18068000 },
        { label: '', freq: 0 },
        { label: '21', freq: 21000000 },
        { label: '24', freq: 24890000 },
        { label: '28', freq: 28000000 },
        { label: '', freq: 0 },
        { label: '50', freq: 50000000 },
        { label: 'GENE', freq: 500000 },
        { label: '', freq: 0 }
    ];
    for (var i = 0; i < bands.length; i++) {
        var b = bands[i];
        var btn = document.createElement('button');
        btn.className = 'ov-btn';
        btn.textContent = b.label;
        if (!b.label) { btn.style.visibility = 'hidden'; }
        else if (b.action === 'freqinp') {
            btn.onclick = function() { setPanel('freqinp'); };
        } else if (b.freq > 0) {
            btn.onclick = (function(f) { return function() {
                send({ cmd: 'setFrequency', value: f });
                setPanel('default');
            }; })(b.freq);
        }
        grid.appendChild(btn);
    }
    // Back button
    var back = document.createElement('button');
    back.className = 'ov-btn back-btn';
    back.innerHTML = '&#x21A9;';
    back.onclick = function() { setPanel('default'); };
    grid.appendChild(back);
    document.getElementById('bandOverlay').classList.add('visible');
}

function renderFuncOverlay() {
    var grid = document.getElementById('funcGrid');
    grid.innerHTML = '';

    // Preamp button
    var preampLabel = 'P.AMP';
    var preampState = 'OFF';
    if (currentPreamp > 0 && availablePreamps.length > 0) {
        for (var p = 0; p < availablePreamps.length; p++) {
            if (availablePreamps[p].num === currentPreamp) { preampState = availablePreamps[p].name; break; }
        }
    }
    var preBtn = makeFuncBtn(preampLabel, preampState, currentPreamp > 0, function() { cyclePreamp(); });
    grid.appendChild(preBtn);

    // Tuner button
    var tunerLabel = 'TUNER';
    var tunerStateStr = tunerState === 0 ? 'OFF' : (tunerState === 2 ? 'TUNING' : 'ON');
    grid.appendChild(makeFuncBtn(tunerLabel, tunerStateStr, tunerState > 0, handleTunerPress));

    // ANF
    grid.appendChild(makeFuncBtn('NOTCH', anfOn ? 'ON' : 'OFF', anfOn, function() { send({ cmd: 'setAutoNotch', value: !anfOn }); }));

    // NB
    grid.appendChild(makeFuncBtn('NB', nbOn ? 'ON' : 'OFF', nbOn, function() { send({ cmd: 'setNoiseBlanker', value: !nbOn }); }));

    // NR
    grid.appendChild(makeFuncBtn('NR', nrOn ? 'ON' : 'OFF', nrOn, function() { send({ cmd: 'setNoiseReduction', value: !nrOn }); }));

    // Second row: Filter buttons
    var filters = availableFilters.length > 0 ? availableFilters : [
        { name: 'FIL1', num: 1 }, { name: 'FIL2', num: 2 }, { name: 'FIL3', num: 3 }
    ];
    for (var f = 0; f < filters.length; f++) {
        var fbtn = document.createElement('button');
        fbtn.className = 'ov-btn' + (currentFilter === filters[f].num ? ' active' : '');
        fbtn.textContent = filters[f].name;
        fbtn.onclick = (function(n) { return function() { send({ cmd: 'setFilter', value: n }); }; })(filters[f].num);
        grid.appendChild(fbtn);
    }

    // Fill remaining slots + back
    var total = grid.children.length;
    var cols = 5;
    var targetSlots = Math.ceil(total / cols) * cols;
    while (grid.children.length < targetSlots - 1) {
        var empty = document.createElement('button');
        empty.className = 'ov-btn';
        empty.style.visibility = 'hidden';
        grid.appendChild(empty);
    }

    var back = document.createElement('button');
    back.className = 'ov-btn back-btn';
    back.innerHTML = '&#x21A9;';
    back.onclick = function() { setPanel('default'); };
    grid.appendChild(back);

    document.getElementById('funcOverlay').classList.add('visible');
}

function makeFuncBtn(label, state, active, onclick) {
    var btn = document.createElement('button');
    btn.className = 'ov-btn' + (active ? ' active' : '');
    btn.innerHTML = '<span class="btn-label">' + label + '</span><span class="btn-state">' + state + '</span>';
    btn.onclick = onclick;
    return btn;
}

function renderAudioMicOverlay() {
    var grid = document.getElementById('audioMicGrid');
    grid.innerHTML = '';

    // RX Audio button
    if (audioAvailable) {
        grid.appendChild(makeFuncBtn('RX AUDIO', audioEnabled ? 'ON' : 'OFF', audioEnabled, function() {
            if (audioEnabled) stopAudio(); else startAudio();
        }));
    }

    // TX Audio (Mic) button
    if (txAudioAvailable && window.isSecureContext) {
        grid.appendChild(makeFuncBtn('TX AUDIO', micEnabled ? 'ON' : 'OFF', micEnabled, function() {
            if (micEnabled) stopMic(); else startMic();
        }));
    }

    // Fill remaining slots + back
    var total = grid.children.length;
    var cols = 5;
    var targetSlots = Math.ceil(total / cols) * cols;
    while (grid.children.length < targetSlots - 1) {
        var empty = document.createElement('button');
        empty.className = 'ov-btn';
        empty.style.visibility = 'hidden';
        grid.appendChild(empty);
    }

    var back = document.createElement('button');
    back.className = 'ov-btn back-btn';
    back.innerHTML = '&#x21A9;';
    back.onclick = function() { setPanel('default'); };
    grid.appendChild(back);

    document.getElementById('audioMicOverlay').classList.add('visible');
}

function cyclePreamp() {
    if (availablePreamps.length === 0) return;
    var idx = -1;
    for (var i = 0; i < availablePreamps.length; i++) {
        if (availablePreamps[i].num === currentPreamp) { idx = i; break; }
    }
    var next = (idx + 1) % availablePreamps.length;
    send({ cmd: 'setPreamp', value: availablePreamps[next].num });
}

function renderSpanOverlay() {
    var grid = document.getElementById('spanGrid');
    grid.innerHTML = '';
    for (var i = 0; i < availableSpans.length; i++) {
        var btn = document.createElement('button');
        btn.className = 'ov-btn' + (i === currentSpanIndex ? ' active' : '');
        btn.textContent = availableSpans[i].name;
        btn.onclick = (function(idx) { return function() { setSpan(idx); setPanel('scope'); }; })(i);
        grid.appendChild(btn);
    }
    var back = document.createElement('button');
    back.className = 'ov-btn back-btn';
    back.innerHTML = '&#x21A9;';
    back.onclick = function() { setPanel('scope'); };
    grid.appendChild(back);
    document.getElementById('spanOverlay').classList.add('visible');
}

// Freq input keypad
function renderFreqInput() {
    freqInputBuf = '';
    document.getElementById('freqInputDisplay').textContent = '0';
    document.getElementById('freqOverlay').classList.add('visible');
}

function freqKey(key) {
    if (key === 'BACK') { setPanel('default'); return; }
    if (key === 'CE') { freqInputBuf = ''; document.getElementById('freqInputDisplay').textContent = '0'; return; }
    if (key === 'ENT') {
        var mhz = parseFloat(freqInputBuf);
        if (!isNaN(mhz) && mhz > 0) {
            send({ cmd: 'setFrequency', value: Math.round(mhz * 1000000) });
        }
        setPanel('default');
        return;
    }
    if (key === 'SPLIT') { toggleSplit(); return; }
    if (key === 'VFO') { swapVFO(); return; }
    if (key === '.') {
        if (freqInputBuf.indexOf('.') === -1) freqInputBuf += '.';
    } else {
        freqInputBuf += key;
    }
    document.getElementById('freqInputDisplay').textContent = freqInputBuf || '0';
}

// Tuner handler
function handleTunerPress() {
    send({ cmd: 'setTuner', value: tunerState > 0 ? 0 : 1 });
}

// Audio/Mic menu functions
function showAudioMicMenu() {
    setPanel('audiomiс');
}

function updateWarningVisibility() {
    var audioWarning = document.getElementById('audioOffWarning');
    var micWarning = document.getElementById('micOffWarning');

    // Show audio warning if audio is available but not enabled
    audioWarning.style.display = (audioAvailable && !audioEnabled) ? 'block' : 'none';

    // Show mic warning if TX audio is available but mic is not enabled
    micWarning.style.display = (txAudioAvailable && window.isSecureContext && !micEnabled) ? 'block' : 'none';
}

function handlePTTPress() {
    // Check if audio is off or mic is off (when TX audio is available)
    var audioNeeded = audioAvailable && !audioEnabled;
    var micNeeded = txAudioAvailable && window.isSecureContext && !micEnabled;

    if (audioNeeded || micNeeded) {
        // Don't transmit, show the menu instead
        showAudioMicMenu();
        return false;
    }

    // All checks passed, allow PTT
    return true;
}

// Long-press TUNE in top bar for tuning
(function() {
    var tuneBtn = document.getElementById('tuneLabel');
    var timer = null, longP = false;
    function down(e) { e.preventDefault(); longP = false; timer = setTimeout(function() { longP = true; send({ cmd: 'setTuner', value: 2 }); }, 500); }
    function up(e) { e.preventDefault(); if (timer) { clearTimeout(timer); timer = null; } if (!longP) send({ cmd: 'setTuner', value: tunerState > 0 ? 0 : 1 }); }
    function cancel() { if (timer) { clearTimeout(timer); timer = null; } }
    tuneBtn.addEventListener('mousedown', down); tuneBtn.addEventListener('mouseup', up);
    tuneBtn.addEventListener('mouseleave', cancel); tuneBtn.addEventListener('touchstart', down);
    tuneBtn.addEventListener('touchend', up); tuneBtn.addEventListener('touchcancel', cancel);
    tuneBtn.style.cursor = 'pointer';
})();

// PTT button (hold to transmit)
(function() {
    var bar = document.getElementById('bottomBar');
    function isPTT(e) { return e.target.classList.contains('ptt-btn'); }
    function pttOn(e) {
        e.preventDefault();
        if (!handlePTTPress()) return; // Check audio/mic, show menu if needed
        flushAudio();
        send({ cmd: 'setPTT', value: true });
    }
    function pttOff(e) { e.preventDefault(); send({ cmd: 'setPTT', value: false }); }
    bar.addEventListener('mousedown', function(e) { if (isPTT(e)) pttOn(e); });
    bar.addEventListener('mouseup', function(e) { if (isPTT(e)) pttOff(e); });
    bar.addEventListener('mouseleave', function() { if (isTransmitting) send({ cmd: 'setPTT', value: false }); });
    bar.addEventListener('touchstart', function(e) { if (isPTT(e)) pttOn(e); });
    bar.addEventListener('touchend', function(e) { if (isPTT(e)) pttOff(e); });
    bar.addEventListener('touchcancel', function() { if (isTransmitting) send({ cmd: 'setPTT', value: false }); });
})();

// ============================================================
// COMMANDS
// ============================================================
function setMode(mode) { send({ cmd: 'setMode', value: mode }); }
function selectVFO(vfo) {
    send({ cmd: 'selectVFO', value: vfo });
    currentVfo = vfo;
    document.getElementById('vfoLabel').textContent = 'VFO ' + vfo;
    renderBottomBar();
    updateOtherVfoDisplay();
}
function swapVFO() {
    send({ cmd: 'swapVFO' });
    // Toggle current VFO tracking
    currentVfo = (currentVfo === 'A') ? 'B' : 'A';
    document.getElementById('vfoLabel').textContent = 'VFO ' + currentVfo;
    updateOtherVfoDisplay();
    renderBottomBar();
}
function equalizeVFO() { send({ cmd: 'equalizeVFO' }); }
function toggleSplit() { send({ cmd: 'setSplit', value: !isSplit }); }
function tuneUp() { if (currentFreq > 0) send({ cmd: 'setFrequency', value: currentFreq + tuneStep }); }
function tuneDown() { if (currentFreq > tuneStep) send({ cmd: 'setFrequency', value: currentFreq - tuneStep }); }
function setSpan(idx) { send({ cmd: 'setSpan', value: idx }); updateSpanIndex(idx); }

// ============================================================
// AUDIO (preserved)
// ============================================================
var audioRingBuf = null, audioRingWrite = 0, audioRingRead = 0;
var audioRingBuffered = 0, audioRingStarted = false, audioPrebufferSamples = 0;
var audioScriptNode = null, audioUseWorklet = false;

function toggleAudio() {
    if (!audioAvailable) return;
    if (audioEnabled) { stopAudio(); return; }
    startAudio();
}

function startAudio() {
    if (audioCtx) stopAudio();
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: audioSampleRate });
    var bufSize = audioCtx.sampleRate * 3;
    audioRingBuf = new Float32Array(bufSize);
    audioRingWrite = 0; audioRingRead = 0; audioRingBuffered = 0;
    audioRingStarted = false;
    audioPrebufferSamples = Math.floor(audioCtx.sampleRate * 0.1);
    if (audioCtx.audioWorklet && window.isSecureContext) startWithWorklet();
    else startWithScriptProcessor();
}

function startWithWorklet() {
    var processorCode = [
        'class WfviewAudioProcessor extends AudioWorkletProcessor {',
        '  constructor() {',
        '    super();',
        '    this.buffer = new Float32Array(sampleRate * 3);',
        '    this.writePos = 0; this.readPos = 0; this.buffered = 0;',
        '    this.started = false;',
        '    this.prebufferSamples = Math.floor(sampleRate * 0.1);',
        '    this.maxBuffered = Math.floor(sampleRate * 0.5);',
        '    this.port.onmessage = (e) => {',
        '      if (e.data === "flush") { this.buffered = 0; this.readPos = this.writePos; this.started = false; return; }',
        '      var samples = e.data; var len = samples.length; var bufLen = this.buffer.length;',
        '      for (var i = 0; i < len; i++) { this.buffer[this.writePos] = samples[i]; this.writePos = (this.writePos + 1) % bufLen; }',
        '      this.buffered += len; if (this.buffered > bufLen) this.buffered = bufLen;',
        '      if (this.started && this.buffered > this.maxBuffered) {',
        '        var target = Math.floor(sampleRate * 0.15); var skip = this.buffered - target;',
        '        this.readPos = (this.readPos + skip) % bufLen; this.buffered -= skip;',
        '      }',
        '    };',
        '  }',
        '  process(inputs, outputs) {',
        '    var output = outputs[0][0]; if (!output) return true;',
        '    if (!this.started && this.buffered < this.prebufferSamples) { output.fill(0); return true; }',
        '    this.started = true; var bufLen = this.buffer.length;',
        '    for (var i = 0; i < output.length; i++) {',
        '      if (this.buffered > 0) { output[i] = this.buffer[this.readPos]; this.readPos = (this.readPos + 1) % bufLen; this.buffered--; }',
        '      else { output[i] = 0; }',
        '    }',
        '    return true;',
        '  }',
        '}',
        'registerProcessor("wfview-audio-processor", WfviewAudioProcessor);'
    ].join('\n');
    var blob = new Blob([processorCode], { type: 'application/javascript' });
    var url = URL.createObjectURL(blob);
    audioCtx.audioWorklet.addModule(url).then(function() {
        URL.revokeObjectURL(url);
        audioWorkletNode = new AudioWorkletNode(audioCtx, 'wfview-audio-processor');
        audioWorkletNode.connect(audioCtx.destination);
        audioUseWorklet = true;
        send({ cmd: 'enableAudio', value: true });
    }).catch(function(err) {
        console.warn('AudioWorklet failed:', err);
        URL.revokeObjectURL(url);
        startWithScriptProcessor();
    });
}

function startWithScriptProcessor() {
    audioScriptNode = audioCtx.createScriptProcessor(4096, 0, 1);
    audioScriptNode.onaudioprocess = function(e) {
        var output = e.outputBuffer.getChannelData(0);
        if (!audioRingStarted && audioRingBuffered < audioPrebufferSamples) { for (var i = 0; i < output.length; i++) output[i] = 0; return; }
        audioRingStarted = true; var bufLen = audioRingBuf.length;
        for (var i = 0; i < output.length; i++) {
            if (audioRingBuffered > 0) { output[i] = audioRingBuf[audioRingRead]; audioRingRead = (audioRingRead + 1) % bufLen; audioRingBuffered--; }
            else output[i] = 0;
        }
    };
    audioScriptNode.connect(audioCtx.destination);
    audioUseWorklet = false;
    send({ cmd: 'enableAudio', value: true });
}

function stopAudio() {
    send({ cmd: 'enableAudio', value: false });
    audioEnabled = false;
    if (audioWorkletNode) { audioWorkletNode.disconnect(); audioWorkletNode = null; }
    if (audioScriptNode) { audioScriptNode.disconnect(); audioScriptNode = null; }
    audioUseWorklet = false; audioRingBuf = null;
    if (audioCtx) { audioCtx.close(); audioCtx = null; }
    renderBottomBar();
    updateWarningVisibility();
    if (currentPanel === 'audiomiс') renderAudioMicOverlay();
}

// TX Audio / Mic (preserved)
function updateTxAudioAvailable(available) {
    txAudioAvailable = available;
    updateWarningVisibility();
}

function toggleMic() {
    if (!txAudioAvailable || !window.isSecureContext) return;
    if (micEnabled) { stopMic(); return; }
    startMic();
}

function startMic() {
    if (micEnabled) return;
    navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } })
    .then(function(stream) {
        micStream = stream;
        micAudioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
        var source = micAudioCtx.createMediaStreamSource(stream);
        var captureCode = [
            'class WfviewCaptureProcessor extends AudioWorkletProcessor {',
            '  constructor() { super(); }',
            '  process(inputs) {',
            '    var input = inputs[0]; if (!input || !input[0] || input[0].length === 0) return true;',
            '    var samples = input[0]; var int16 = new Int16Array(samples.length);',
            '    for (var i = 0; i < samples.length; i++) { var s = Math.max(-1, Math.min(1, samples[i])); int16[i] = s < 0 ? s * 32768 : s * 32767; }',
            '    this.port.postMessage(int16.buffer, [int16.buffer]); return true;',
            '  }',
            '}',
            'registerProcessor("wfview-capture-processor", WfviewCaptureProcessor);'
        ].join('\n');
        var blob = new Blob([captureCode], { type: 'application/javascript' });
        var url = URL.createObjectURL(blob);
        micAudioCtx.audioWorklet.addModule(url).then(function() {
            URL.revokeObjectURL(url);
            micWorkletNode = new AudioWorkletNode(micAudioCtx, 'wfview-capture-processor');
            source.connect(micWorkletNode);
            micWorkletNode.connect(micAudioCtx.destination);
            micWorkletNode.port.onmessage = function(e) {
                if (!micEnabled || !ws || ws.readyState !== WebSocket.OPEN) return;
                var pcmBuffer = e.data;
                var frame = new ArrayBuffer(6 + pcmBuffer.byteLength);
                var view = new DataView(frame);
                view.setUint8(0, 0x03); view.setUint8(1, 0x00);
                view.setUint16(2, micSeq++ & 0xFFFF, true); view.setUint16(4, 0, true);
                new Uint8Array(frame, 6).set(new Uint8Array(pcmBuffer));
                ws.send(frame);
            };
            micEnabled = true;
            send({ cmd: 'enableMic', value: true });
            renderBottomBar();
            updateWarningVisibility();
            if (currentPanel === 'audiomiс') renderAudioMicOverlay();
        }).catch(function(err) { console.error('Mic AudioWorklet failed:', err); stopMic(); });
    }).catch(function(err) { console.error('getUserMedia failed:', err); });
}

function stopMic() {
    send({ cmd: 'enableMic', value: false }); micEnabled = false;
    if (micWorkletNode) { micWorkletNode.disconnect(); micWorkletNode = null; }
    if (micStream) { micStream.getTracks().forEach(function(t) { t.stop(); }); micStream = null; }
    if (micAudioCtx) { micAudioCtx.close(); micAudioCtx = null; }
    micSeq = 0; renderBottomBar();
    updateWarningVisibility();
    if (currentPanel === 'audiomiс') renderAudioMicOverlay();
}

function handleAudioData(buffer) {
    if (!audioEnabled || isTransmitting) return;
    if (buffer.byteLength < 8) return;
    var pcmData = new Int16Array(buffer, 6);
    var floatData = new Float32Array(pcmData.length);
    for (var i = 0; i < pcmData.length; i++) floatData[i] = pcmData[i] / 32768.0;
    if (audioUseWorklet && audioWorkletNode) {
        audioWorkletNode.port.postMessage(floatData);
    } else if (audioRingBuf) {
        var len = floatData.length, bufLen = audioRingBuf.length;
        for (var i = 0; i < len; i++) { audioRingBuf[audioRingWrite] = floatData[i]; audioRingWrite = (audioRingWrite + 1) % bufLen; }
        audioRingBuffered += len; if (audioRingBuffered > bufLen) audioRingBuffered = bufLen;
        var maxBuf = Math.floor(audioSampleRate * 0.5);
        if (audioRingStarted && audioRingBuffered > maxBuf) {
            var target = Math.floor(audioSampleRate * 0.15), skip = audioRingBuffered - target;
            audioRingRead = (audioRingRead + skip) % bufLen; audioRingBuffered -= skip;
        }
    }
}

function flushAudio() {
    if (audioUseWorklet && audioWorkletNode) audioWorkletNode.port.postMessage('flush');
    else if (audioRingBuf) { audioRingBuffered = 0; audioRingRead = audioRingWrite; audioRingStarted = false; }
}

// ============================================================
// SPECTRUM / WATERFALL
// ============================================================
function buildColorTable() {
    colorTable = new Array(256);
    for (var i = 0; i < 256; i++) {
        var v = i / 255; var r, g, b;
        if (v < 0.25) { r = 0; g = Math.round(255 * (v / 0.25)); b = 255; }
        else if (v < 0.5) { r = 0; g = 255; b = Math.round(255 * (1 - (v - 0.25) / 0.25)); }
        else if (v < 0.75) { r = Math.round(255 * ((v - 0.5) / 0.25)); g = 255; b = 0; }
        else { r = 255; g = Math.round(255 * (1 - (v - 0.75) / 0.25)); b = 0; }
        colorTable[i] = [r, g, b];
    }
}

function resizeCanvases() {
    var spectCanvas = document.getElementById('spectrumCanvas');
    var wfCanvas = document.getElementById('waterfallCanvas');
    var area = document.getElementById('scopeArea');
    var areaRect = area.getBoundingClientRect();
    if (areaRect.width <= 0 || areaRect.height <= 0) return;

    var spectH = Math.round(areaRect.height * 0.35);
    var wfH = Math.round(areaRect.height * 0.65);
    spectCanvas.style.height = spectH + 'px';
    wfCanvas.style.top = spectH + 'px';
    wfCanvas.style.height = wfH + 'px';
    spectCanvas.width = Math.round(areaRect.width);
    spectCanvas.height = spectH;
    wfCanvas.width = Math.round(areaRect.width);
    wfCanvas.height = wfH;
    if (spectDataLen > 0) initWaterfallBuffer(spectDataLen);
    // Redraw meter for new DPI
    drawMeter();
}

function initWaterfallBuffer(dataLen) {
    var wfCanvas = document.getElementById('waterfallCanvas');
    var h = wfCanvas.height || 200;
    wfOffCanvas = document.createElement('canvas');
    wfOffCanvas.width = dataLen; wfOffCanvas.height = h;
    wfOffCtx = wfOffCanvas.getContext('2d');
    wfImageData = wfOffCtx.createImageData(dataLen, h);
    var d = wfImageData.data;
    for (var i = 3; i < d.length; i += 4) d[i] = 255;
}

function handleBinaryMessage(buffer) {
    if (buffer.byteLength < 2) return;
    var view = new DataView(buffer);
    var msgType = view.getUint8(0);
    if (msgType === 0x02) { handleAudioData(buffer); return; }
    if (msgType !== 0x01 || buffer.byteLength < 13) return;

    spectStartFreq = view.getFloat32(4, true);
    spectEndFreq = view.getFloat32(8, true);
    spectData = new Uint8Array(buffer, 12);
    if (spectData.length !== spectDataLen) { spectDataLen = spectData.length; initWaterfallBuffer(spectDataLen); }

    // Update scope edge labels
    if (spectStartFreq > 0 && spectEndFreq > spectStartFreq) {
        var halfSpan = (spectEndFreq - spectStartFreq) / 2;
        document.getElementById('spanEdgeLeft').textContent = '-' + (halfSpan * 1000).toFixed(0);
        document.getElementById('spanEdgeRight').textContent = '+' + (halfSpan * 1000).toFixed(0);
    }

    updateWaterfallRow();
    if (!spectRenderPending) { spectRenderPending = true; requestAnimationFrame(renderScope); }
}

function updateWaterfallRow() {
    if (!wfImageData || !spectData) return;
    var w = wfImageData.width, d = wfImageData.data;
    d.copyWithin(w * 4, 0, d.length - w * 4);
    for (var i = 0; i < w; i++) {
        var amp = i < spectData.length ? spectData[i] : 0;
        var ci = Math.min(255, Math.round((amp / spectAmpMax) * 255));
        var c = colorTable[ci];
        var idx = i * 4;
        d[idx] = c[0]; d[idx+1] = c[1]; d[idx+2] = c[2]; d[idx+3] = 255;
    }
}

function renderScope() {
    spectRenderPending = false;
    if (!spectData || spectData.length === 0) return;
    drawSpectrum();
    drawWaterfall();
}

function drawSpectrum() {
    var canvas = document.getElementById('spectrumCanvas');
    var ctx = canvas.getContext('2d');
    var w = canvas.width, h = canvas.height, len = spectData.length;
    var labelH = 14, plotH = h - labelH;

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, w, h);

    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    for (var gi = 1; gi < 4; gi++) {
        var gy = (plotH / 4) * gi;
        ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(w, gy); ctx.stroke();
    }

    // Fill
    ctx.beginPath(); ctx.moveTo(0, plotH);
    for (var i = 0; i < len; i++) {
        ctx.lineTo((i / (len - 1)) * w, plotH - (spectData[i] / spectAmpMax) * plotH);
    }
    ctx.lineTo(w, plotH); ctx.closePath();
    ctx.fillStyle = 'rgba(0, 200, 200, 0.08)';
    ctx.fill();

    // Line
    ctx.beginPath();
    for (var j = 0; j < len; j++) {
        var lx = (j / (len - 1)) * w, ly = plotH - (spectData[j] / spectAmpMax) * plotH;
        if (j === 0) ctx.moveTo(lx, ly); else ctx.lineTo(lx, ly);
    }
    ctx.strokeStyle = '#0bb';
    ctx.lineWidth = 1.2;
    ctx.stroke();

    // Frequency marker (IC-7300 style: white triangle + vertical line)
    if (currentFreq > 0 && spectStartFreq > 0 && spectEndFreq > spectStartFreq) {
        var freqMHz = currentFreq / 1e6;
        if (freqMHz >= spectStartFreq && freqMHz <= spectEndFreq) {
            var fxPos = ((freqMHz - spectStartFreq) / (spectEndFreq - spectStartFreq)) * w;
            // Vertical line
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(fxPos, 0); ctx.lineTo(fxPos, plotH); ctx.stroke();
            // White triangle at bottom
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(fxPos - 5, plotH);
            ctx.lineTo(fxPos + 5, plotH);
            ctx.lineTo(fxPos, plotH - 7);
            ctx.closePath();
            ctx.fill();
        }
    }

    // Freq labels
    if (spectStartFreq > 0 && spectEndFreq > spectStartFreq) {
        ctx.fillStyle = '#555';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        for (var li = 0; li <= 5; li++) {
            var frac = li / 5;
            var freq = spectStartFreq + (spectEndFreq - spectStartFreq) * frac;
            var label = freq >= 1000 ? freq.toFixed(1) : freq >= 100 ? freq.toFixed(2) : freq.toFixed(3);
            ctx.fillText(label, frac * w, plotH + 2);
        }
    }
}

function drawWaterfall() {
    if (!wfImageData || !wfOffCtx) return;
    var canvas = document.getElementById('waterfallCanvas');
    var ctx = canvas.getContext('2d');
    var w = canvas.width, h = canvas.height;
    wfOffCtx.putImageData(wfImageData, 0, 0);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(wfOffCanvas, 0, 0, w, h);

    // Frequency indicator
    if (currentFreq > 0 && spectStartFreq > 0 && spectEndFreq > spectStartFreq) {
        var freqMHz = currentFreq / 1e6;
        if (freqMHz >= spectStartFreq && freqMHz <= spectEndFreq) {
            var xPos = ((freqMHz - spectStartFreq) / (spectEndFreq - spectStartFreq)) * w;
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(xPos, 0); ctx.lineTo(xPos, h); ctx.stroke();
        }
    }
}

function scopeClick(e) {
    if (spectStartFreq <= 0 || spectEndFreq <= spectStartFreq) return;
    var rect = e.target.getBoundingClientRect();
    var frac = (e.clientX - rect.left) / rect.width;
    var freqHz = Math.round((spectStartFreq + (spectEndFreq - spectStartFreq) * frac) * 1e6);
    if (freqHz > 0) send({ cmd: 'setFrequency', value: freqHz });
}

function scopeWheel(e) {
    e.preventDefault();
    if (e.deltaY < 0) tuneUp(); else tuneDown();
}

// ============================================================
// CLOCK
// ============================================================
function updateClock() {
    var now = new Date();
    document.getElementById('clock').textContent =
        String(now.getUTCHours()).padStart(2, '0') + ':' +
        String(now.getUTCMinutes()).padStart(2, '0');
}

// ============================================================
// KEYBOARD
// ============================================================
var spacebarPTTActive = false;

document.addEventListener('keydown', function(e) {
    if (e.target.tagName === 'INPUT') return;
    if (e.key === 'ArrowUp' || e.key === '+') { e.preventDefault(); tuneUp(); }
    else if (e.key === 'ArrowDown' || e.key === '-') { e.preventDefault(); tuneDown(); }
    else if (e.key === 'Escape') { hideAllOverlays(); setPanel('default'); }
    else if (e.key === ' ' && !e.repeat) {
        e.preventDefault();
        if (!spacebarPTTActive && handlePTTPress()) {
            spacebarPTTActive = true;
            flushAudio();
            send({ cmd: 'setPTT', value: true });
        }
    }
});

document.addEventListener('keyup', function(e) {
    if (e.key === ' ' && spacebarPTTActive) {
        e.preventDefault();
        spacebarPTTActive = false;
        send({ cmd: 'setPTT', value: false });
    }
});

document.getElementById('freqDisplay').addEventListener('wheel', function(e) {
    e.preventDefault();
    if (e.deltaY < 0) tuneUp(); else tuneDown();
}, { passive: false });

document.getElementById('freqDisplay').addEventListener('click', function() {
    setPanel('freqinp');
});

// ============================================================
// INIT
// ============================================================
console.log('=== WFVIEW WEB UI v2.1.0 (2026-02-16) - Dual VFO Support ===');

buildColorTable();
initSliderTracking();
renderBottomBar();
drawMeter();
updateClock();
setInterval(updateClock, 10000);

// Initialize scope info bar
var otherVfoElem = document.getElementById('otherVfoFreq');
if (otherVfoElem) updateOtherVfoDisplay();

document.getElementById('spectrumCanvas').addEventListener('click', scopeClick);
document.getElementById('waterfallCanvas').addEventListener('click', scopeClick);
document.getElementById('spectrumCanvas').addEventListener('wheel', scopeWheel, { passive: false });
document.getElementById('waterfallCanvas').addEventListener('wheel', scopeWheel, { passive: false });
window.addEventListener('resize', resizeCanvases);
requestAnimationFrame(resizeCanvases);

connect();
</script>
</body>
</html>
