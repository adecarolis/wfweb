<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>wfview</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
    height: 100%; overflow: hidden;
    font-family: system-ui, -apple-system, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: #000; color: #e0e0e0;
    touch-action: manipulation;
    user-select: none; -webkit-user-select: none;
}

:root {
    --viewport-height: 100vh;
}

#radio {
    display: grid;
    grid-template-rows: 34px 80px 20px 1fr 48px;
    width: 100%;
    height: var(--viewport-height);
    height: 100dvh; /* Dynamic viewport height for modern browsers */
    max-width: calc(100vh * 16 / 9);
    margin: 0 auto;
    overflow: hidden;
    background: #0a0a0a;
}

/* ============ ROW 1: TOP BAR ============ */
#topBar {
    display: flex; align-items: center;
    padding: 0 6px; gap: 6px;
    background: #111;
    font-size: 12px;
    border-bottom: 1px solid #282828;
    z-index: 2;
}
#txIndicator {
    display: inline-block;
    padding: 2px 8px; border-radius: 4px;
    font-weight: bold; font-size: 11px;
    border: 1px solid #600;
    background: transparent; color: #600;
    min-width: 28px; text-align: center;
}
#txIndicator.tx {
    background: #c00; color: #fff;
    border-color: #c00;
    animation: txBlink 0.8s infinite;
}
@keyframes txBlink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}
@keyframes tuneBlink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}
#tuneLabel {
    font-size: 11px; font-weight: bold;
    color: #888;
    display: none;
}
#tuneLabel.active {
    display: inline-block;
    color: #c00;
}
#tuneLabel.tuning {
    animation: tuneBlink 0.5s infinite;
}
#modeBtn {
    padding: 3px 14px; border-radius: 5px;
    border: 2px solid #0aa;
    background: transparent; color: #fff;
    cursor: pointer; font-size: 12px;
    font-weight: bold; letter-spacing: 0.5px;
}
#modeBtn:active { background: #0aa; color: #000; }
#pbBars {
    display: inline-flex; align-items: center; gap: 4px;
    height: 16px;
}
#pbBars i {
    display: block; width: 2px; height: 12px;
    background: #888; border-radius: 1px;
}
#filterText { color: #888; font-size: 11px; font-weight: bold; }
#dspIndicators { display: flex; gap: 4px; margin-left: 6px; }
.dsp-tag {
    font-size: 9px; font-weight: bold;
    padding: 1px 4px;
    background: #4488cc;
    color: #fff;
    border-radius: 2px;
}
.flex-space { flex: 1; }
#clock { color: #888; font-family: 'Courier New', monospace; font-size: 11px; }
#stepLabel { color: #666; font-size: 10px; }
#connDot {
    width: 8px; height: 8px; border-radius: 50%;
    background: #600; flex-shrink: 0;
}
#connDot.connected { background: #0a0; }

/* ============ ROW 2: METER + FREQUENCY ============ */
#meterFreqRow {
    display: flex; align-items: stretch;
    background: #0a0a0a;
    padding: 0 8px;
    gap: 8px;
}
#meterSection {
    flex: 0 0 45%;
    display: flex; align-items: center;
}
#meterCanvas {
    width: 100%; height: 64px;
}
#freqSection {
    flex: 1;
    display: flex; flex-direction: column;
    justify-content: center;
    align-items: flex-end;
    padding-right: 2px;
    min-width: 0;
}
#vfoLine {
    display: flex; align-items: center; gap: 6px;
    font-size: 12px; margin-bottom: 2px;
}
#vfoLabel { color: #aaa; font-weight: bold; }
#vfoNum { color: #888; }
#splitBadge {
    padding: 1px 6px; border-radius: 3px;
    background: #d22; color: #fff;
    font-size: 10px; font-weight: bold;
}
#splitBadge.hidden { display: none; }
#splitFreq { color: #666; font-family: 'Courier New', monospace; font-size: 13px; }
#splitFreq.hidden { display: none; }

#freqDisplay {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    cursor: pointer;
    white-space: nowrap;
    line-height: 1;
    height: 50px;
}
.freq-digit {
    display: inline-block;
    width: 50px;
    height: 50px;
    background-image: url('digits-sprite.png');
    background-repeat: no-repeat;
    background-size: 512px 50px; /* 2x scale: 256px -> 512px */
}
.freq-digit.digit-0 { background-position: 0px 0; }
.freq-digit.digit-1 { background-position: -50px 0; }
.freq-digit.digit-2 { background-position: -102px 0; }
.freq-digit.digit-3 { background-position: -150px 0; }
.freq-digit.digit-4 { background-position: -200px 0; }
.freq-digit.digit-5 { background-position: -250px 0; }
.freq-digit.digit-6 { background-position: -300px 0; }
.freq-digit.digit-7 { background-position: -350px 0; }
.freq-digit.digit-8 { background-position: -400px 0; }
.freq-digit.digit-9 { background-position: -450px 0; }
.freq-digit.digit-dot { background-position: -500px 0; width: 12px; }

/* ============ ROW 3: SCOPE INFO BAR ============ */
#scopeInfoBar {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    padding: 0 8px;
    background: #0d0d0d;
    font-size: 10px; color: #555;
    border-top: 1px solid #1a1a1a;
    border-bottom: 1px solid #1a1a1a;
    overflow: hidden;
}
#scopeInfoBar span { white-space: nowrap; }
#spanIndicator {
    color: #0cc;
    font-size: 11px;
    font-weight: bold;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 2px;
    justify-self: start;
}
#spanIndicator:hover {
    background: #1a2828;
    color: #0cc;
}
#scopeLabel {
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #444;
    justify-self: center;
}
#otherVfoFreq {
    color: #888;
    font-size: 10px;
    font-family: 'Courier New', monospace;
    justify-self: end;
}

/* ============ ROW 4: SCOPE AREA ============ */
#scopeArea {
    position: relative;
    overflow: hidden;
    background: #000;
}
#spectrumCanvas, #waterfallCanvas {
    display: block; width: 100%;
    position: absolute; left: 0;
    cursor: crosshair;
}
#spectrumCanvas {
    top: 0; height: 35%;
    background: #050510;
}
#waterfallCanvas {
    top: 35%; height: 65%;
    background: #000;
    image-rendering: pixelated;
}
/* Span labels at edges of spectrum */
#spanEdgeLeft, #spanEdgeRight {
    position: absolute; top: 35%;
    transform: translateY(-100%);
    font-size: 9px; color: #666;
    padding: 1px 3px;
    pointer-events: none;
}
#spanEdgeLeft { left: 2px; }
#spanEdgeRight { right: 2px; }

/* ---- Overlays (inside scope area) ---- */
.overlay {
    display: none;
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(8,8,8,0.96);
    z-index: 10;
}
.overlay.visible { display: flex; }

/* Macro editor overlay - higher z-index to appear above CW bar */
#cwMacroEditor {
    z-index: 250;
    padding: 20px;
    align-items: flex-start;
    overflow-y: auto;
}
#cwMacroEditor .editor-dialog {
    background: #000;
    border: 2px solid #0a0;
    padding: 16px;
    max-width: 90%;
    width: 350px;
    margin: auto;
    margin-top: 40px;
    box-shadow: 0 4px 20px rgba(0,255,0,0.3);
}
#cwMacroEditor .editor-title {
    color: #0f0;
    font-size: 14px;
    font-weight: bold;
    margin-bottom: 8px;
    text-transform: uppercase;
}
#cwMacroEditor .editor-hint {
    color: #888;
    font-size: 11px;
    margin-bottom: 12px;
}
#cwMacroEditor textarea {
    width: 100%;
    height: 70px;
    background: #001a00;
    border: 1px solid #0a0;
    color: #0f0;
    font-family: monospace;
    padding: 8px;
    font-size: 13px;
    resize: vertical;
    box-sizing: border-box;
    text-transform: uppercase;
}
#cwMacroEditor .editor-buttons {
    margin-top: 12px;
    display: flex;
    gap: 8px;
}
#cwMacroEditor .editor-buttons button {
    flex: 1;
    border: none;
    padding: 10px 6px;
    font-weight: bold;
    cursor: pointer;
    font-size: 11px;
    text-transform: uppercase;
}
#cwMacroSave {
    background: #0a0;
    color: #000;
}
#cwMacroClear {
    background: #333;
    color: #888;
}
#cwMacroCancel {
    background: #1a1a1a;
    color: #0a0;
    border: 1px solid #0a0 !important;
}

/* Responsive sizing for macro editor */
@media (min-width: 600px) {
    #cwMacroEditor .editor-dialog {
        max-width: 400px;
    }
}
@media (orientation: portrait) and (max-width: 600px) {
    #cwMacroEditor {
        padding: 0;
        align-items: flex-start;
    }
    #cwMacroEditor .editor-dialog {
        padding: 12px;
        width: calc(100% - 20px);
        margin: 10px;
        margin-top: 20px;
        max-height: 50vh;
    }
    #cwMacroEditor textarea {
        height: 50px;
        font-size: 12px;
    }
    #cwMacroEditor .editor-buttons button {
        padding: 8px 4px;
        font-size: 10px;
    }
}

/* Overlay title */
.overlay-title {
    text-align: center;
    font-size: 12px; color: #888;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 8px 0 6px;
}

/* MODE overlay - 3 columns grid */
#modeOverlay.visible {
    flex-direction: column;
    padding: 4px 12px;
}
#modeOverlay .overlay-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px; padding: 4px 0;
    flex: 1; align-content: center;
}

/* BAND overlay - 4 columns grid */
#bandOverlay.visible {
    flex-direction: column;
    padding: 4px 12px;
}
#bandOverlay .overlay-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px; padding: 4px 0;
    flex: 1; align-content: center;
}

/* FUNCTION overlay - 5 columns grid */
#funcOverlay.visible {
    flex-direction: column;
    padding: 4px 8px;
}
#funcOverlay .overlay-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 5px; padding: 4px 0;
    flex: 1; align-content: center;
}

/* AUDIO/MIC overlay */
#audioMicOverlay.visible {
    flex-direction: column;
    padding: 4px 12px;
}
#audioMicOverlay .overlay-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 5px; padding: 4px 0;
    flex: 1; align-content: center;
}

/* SPAN overlay */
#spanOverlay.visible {
    flex-direction: column;
    padding: 4px 12px;
}
#spanOverlay .overlay-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px; padding: 4px 0;
    flex: 1; align-content: center;
}

/* Overlay button */
.ov-btn {
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    min-height: 44px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #222;
    color: #ddd;
    cursor: pointer;
    font-size: 13px; font-weight: bold;
}
.ov-btn:active { background: #444; }
.ov-btn.active {
    border-color: #0aa;
    box-shadow: 0 0 6px rgba(0,170,170,0.3);
}
.ov-btn .btn-label { font-size: 13px; font-weight: bold; }
.ov-btn .btn-state {
    font-size: 10px; font-weight: normal;
    margin-top: 2px;
}
.ov-btn.active .btn-state { color: #0cc; }
.ov-btn:not(.active) .btn-state { color: #666; }
.ov-btn.back-btn {
    border-color: #555;
    color: #888;
    font-size: 18px;
}

/* CW Bar - RTTY decoder style (green terminal theme) */
.cw-bar {
    position: fixed;
    bottom: 44px; /* Raise above bottom bar */
    left: 0;
    right: 0;
    background: #000;
    border-top: 2px solid #0a0;
    z-index: 200;
    display: flex;
    flex-direction: column;
    max-height: calc(100vh - 44px);
    overflow-y: auto;
}
.cw-bar.hidden { display: none; }

.cw-bar-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 6px 10px;
    background: #000;
    border-bottom: 1px solid #0a0;
    font-size: 14px;
}

/* Mobile portrait: more compact CW bar */
@media (orientation: portrait) and (max-width: 600px) {
    .cw-bar-header {
        gap: 4px;
        padding: 3px 4px;
        font-size: 11px;
        flex-wrap: wrap; /* Allow wrapping to multiple rows */
    }
    .cw-label { display: none; } /* Hide "CW" label - obvious from context */
    .cw-speed-ctrl { gap: 2px; }
    .cw-speed-btn { width: 22px; height: 22px; font-size: 14px; padding: 0; }
    #cwSpeedInput { width: 32px; height: 22px; font-size: 11px; padding: 2px; }
    .cw-wpm-label { display: none; } /* Hide "WPM" - obvious from context */
    .cw-mode-btn { padding: 2px 6px; font-size: 10px; }
    .cw-stop-btn, .cw-close-btn, .cw-edit-btn { padding: 2px 6px; font-size: 10px; }
    .cw-display { font-size: 11px; padding: 3px 4px; min-height: 18px; }
    .cw-input-field { font-size: 11px; padding: 3px 4px; }
    .cw-macro-grid { gap: 3px; padding: 4px 6px; }
    .cw-macro-btn { padding: 6px 3px; font-size: 9px; min-height: 28px; }
    .cw-callsign-row { padding: 3px 6px; gap: 4px; }
    .cw-callsign-label { font-size: 10px; }
    .cw-callsign-input { font-size: 11px; padding: 3px 4px; max-width: 100px; }
}
.cw-label {
    color: #0f0;
    font-weight: bold;
    font-size: 16px;
    padding-right: 8px;
    font-family: monospace;
}
.cw-speed-ctrl {
    display: flex;
    align-items: center;
    gap: 4px;
}
.cw-speed-btn {
    width: 28px;
    height: 28px;
    background: #001a00;
    border: 1px solid #0a0;
    color: #0f0;
    font-size: 18px;
    line-height: 1;
    cursor: pointer;
    padding: 0;
    font-weight: bold;
}
.cw-speed-btn:active {
    background: #0a0;
    color: #000;
}
#cwSpeedInput {
    width: 40px;
    height: 28px;
    background: #000;
    border: 1px solid #0a0;
    color: #0f0;
    text-align: center;
    font-size: 14px;
    font-family: monospace;
    font-weight: bold;
    padding: 0 4px;
}
#cwSpeedInput:focus {
    outline: none;
    border-color: #0f0;
    box-shadow: 0 0 4px #0a0;
}
.cw-wpm-label {
    color: #0a0;
    font-size: 12px;
    padding-right: 8px;
    font-family: monospace;
}
.cw-mode-btns {
    display: flex;
    gap: 4px;
    margin-left: auto;
}
.cw-mode-btn {
    padding: 4px 10px;
    background: #001a00;
    border: 1px solid #0a0;
    color: #0a0;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
    font-family: monospace;
}
.cw-mode-btn.active {
    background: #0a0;
    border-color: #0f0;
    color: #000;
}
.cw-stop-btn {
    padding: 4px 12px;
    background: #1a0000;
    border: 1px solid #a00;
    color: #f44;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
    margin-left: 8px;
    font-family: monospace;
}
.cw-stop-btn:active {
    background: #c00;
    color: #fff;
}
.cw-edit-btn {
    padding: 4px 10px;
    background: #001a00;
    border: 1px solid #0a0;
    color: #0a0;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
    margin-left: 8px;
    font-family: monospace;
}
.cw-edit-btn:active {
    background: #0a0;
    color: #000;
}
.cw-edit-btn.editing {
    background: #0a0;
    color: #000;
}
.cw-close-btn {
    padding: 4px 10px;
    background: #001a00;
    border: 1px solid #0a0;
    color: #0a0;
    font-size: 14px;
    cursor: pointer;
    margin-left: 8px;
    font-weight: bold;
}
.cw-close-btn:active {
    background: #0a0;
    color: #000;
}
.cw-display {
    background: #000;
    color: #0f0;
    font-family: 'Courier New', 'Consolas', monospace;
    font-size: 15px;
    font-weight: bold;
    padding: 8px 10px;
    overflow-x: auto;
    white-space: pre;
    border-bottom: 1px solid #0a0;
    min-height: 30px;
    letter-spacing: 1px;
}
.cw-char {
    display: inline-block;
}
.cw-char.sent {
    color: #052;
}
.cw-char.pending {
    color: #0f0;
}
.cw-char.sending {
    color: #0f0;
    text-shadow: 0 0 4px #0f0;
}
.cw-cursor {
    color: #0f0;
    animation: blink 1s step-end infinite;
}
@keyframes blink {
    50% { opacity: 0; }
}
.cw-input-field {
    width: 100%;
    background: #000;
    border: none;
    color: #0f0;
    font-family: 'Courier New', 'Consolas', monospace;
    font-size: 15px;
    font-weight: bold;
    padding: 8px 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
}
.cw-input-field:focus {
    outline: none;
    background: #001a00;
}
.cw-input-field::placeholder {
    color: #052;
    text-transform: none;
}
.cw-callsign-row {
    display: flex;
    gap: 8px;
    padding: 4px 10px;
    background: #000;
    border-bottom: 1px solid #0a0;
    align-items: center;
}
.cw-callsign-label {
    color: #888;
    font-size: 11px;
    font-weight: bold;
    min-width: 35px;
}
.cw-callsign-input {
    flex: 1;
    max-width: 120px;
    background: #001a00;
    border: 1px solid #0a0;
    color: #0f0;
    font-family: 'Courier New', 'Consolas', monospace;
    font-size: 14px;
    font-weight: bold;
    padding: 4px 6px;
    text-transform: uppercase;
}
.cw-callsign-input:focus {
    outline: none;
    background: #002a00;
    border-color: #0f0;
}
.cw-macro-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 4px;
    padding: 6px 10px;
    background: #0a0a0a;
}
.cw-macro-btn {
    background: #1a1a1a;
    border: 1px solid #0a0;
    color: #0a0;
    padding: 8px 4px;
    font-size: 11px;
    font-weight: bold;
    cursor: pointer;
    text-align: center;
    min-height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Courier New', monospace;
    text-transform: uppercase;
}
.cw-macro-btn:hover {
    background: #002a00;
    border-color: #0f0;
}
.cw-macro-btn:active {
    background: #0a0;
    color: #000;
}
.cw-macro-btn.empty {
    color: #333;
    font-style: italic;
}
.cw-macro-btn.editable {
    border: 2px solid #ff0;
    animation: pulse-border 1.5s ease-in-out infinite;
}
.cw-macro-btn.edit-set-btn {
    background: #001a00;
    border: 1px solid #0a0;
    color: #0a0;
    font-size: 10px;
}
.cw-macro-btn.edit-set-btn.editing {
    background: #0a0;
    color: #000;
}
@keyframes pulse-border {
    0%, 100% { border-color: #ff0; }
    50% { border-color: #aa0; }
}

/* GAIN overlay */
#gainOverlay.visible {
    flex-direction: column;
    justify-content: center;
    padding: 10px 16px;
    gap: 8px;
}
.gain-row {
    display: flex; align-items: center; gap: 8px;
}
.gain-label {
    font-size: 11px; color: #888; text-transform: uppercase;
    width: 35px; text-align: right; letter-spacing: 1px;
    flex-shrink: 0; font-weight: bold;
}
.gain-bar-bg {
    flex: 1; height: 20px;
    background: #222; border-radius: 2px;
    position: relative; overflow: hidden;
    cursor: pointer;
}
.gain-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #066, #0aa);
    border-radius: 2px;
    transition: width 0.05s linear;
}
.gain-val {
    font-family: 'Courier New', monospace;
    font-size: 12px; width: 40px;
    text-align: right; color: #0aa;
    flex-shrink: 0;
}
/* Hidden range inputs over the gain bars */
.gain-row input[type="range"] {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    opacity: 0; cursor: pointer;
    margin: 0;
}

/* FREQ INPUT overlay */
#freqOverlay.visible {
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    padding: 8px;
}
#freqInputDisplay {
    font-family: 'Courier New', monospace;
    font-size: 32px; font-weight: bold;
    color: #fff;
    min-height: 42px;
    text-align: center;
    letter-spacing: 1px;
}
#freqKeypad {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 5px;
    width: 100%;
    max-width: 340px;
}
.key-btn {
    height: 44px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #222;
    color: #ddd;
    cursor: pointer;
    font-size: 16px; font-weight: bold;
}
.key-btn:active { background: #444; }
.key-btn.key-ent {
    border-color: #0aa; color: #0aa;
}

/* ============ ROW 5: BOTTOM BAR ============ */
#bottomBar {
    display: flex;
    padding: 4px 6px;
    padding-bottom: calc(4px + env(safe-area-inset-bottom));
    gap: 4px;
    background: #111;
    border-top: 1px solid #282828;
    align-items: center;
}
.softBtn {
    flex: 1; height: 38px;
    border: 1px solid #444;
    border-radius: 6px;
    background: #252525;
    color: #ccc;
    cursor: pointer;
    font-size: 12px; font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
.softBtn:active { background: #444; }
.softBtn.active {
    border-color: #0aa;
    color: #0cc;
    background: #1a2828;
}
.softBtn.tx-active {
    border-color: #c00;
    color: #f44;
    background: #281a1a;
}
.softBtn.ptt-btn {
    background: #1a1a1a;
    border-color: #600;
    color: #a44;
}
.softBtn.ptt-btn.tx-active {
    background: #800;
    border-color: #f00;
    color: #fff;
}
.softBtn.key-btn {
    background: #1a1a1a;
    border-color: #660;
    color: #aa4;
}
.softBtn.key-btn.tx-active {
    background: #880;
    border-color: #ff0;
    color: #fff;
}

/* ============ SPECTRUM WARNINGS ============ */
.spectrum-warning {
    position: absolute;
    top: 4px;
    left: 6px;
    font-size: 11px;
    font-weight: bold;
    color: #c80;
    cursor: pointer;
    z-index: 50;
    padding: 2px 6px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 3px;
    letter-spacing: 0.5px;
    user-select: none;
}
.spectrum-warning:hover {
    color: #fa0;
    background: rgba(0, 0, 0, 0.7);
}
#micOffWarning {
    top: 22px; /* Position below audio warning if both shown */
}

/* ============ RESPONSIVE ============ */
@media (max-height: 450px) {
    #radio { grid-template-rows: 28px 64px 16px 1fr 40px; }
    #freqDisplay { height: 32px; }
    #freqDisplay .freq-digit { width: 32px; height: 32px; background-size: 332px 32px; }
    #freqDisplay .freq-digit.digit-0 { background-position: 0px 0; }
    #freqDisplay .freq-digit.digit-1 { background-position: -32px 0; }
    #freqDisplay .freq-digit.digit-2 { background-position: -66px 0; }
    #freqDisplay .freq-digit.digit-3 { background-position: -97px 0; }
    #freqDisplay .freq-digit.digit-4 { background-position: -130px 0; }
    #freqDisplay .freq-digit.digit-5 { background-position: -162px 0; }
    #freqDisplay .freq-digit.digit-6 { background-position: -195px 0; }
    #freqDisplay .freq-digit.digit-7 { background-position: -227px 0; }
    #freqDisplay .freq-digit.digit-8 { background-position: -260px 0; }
    #freqDisplay .freq-digit.digit-9 { background-position: -292px 0; }
    #freqDisplay .freq-digit.digit-dot { width: 7px; background-position: -325px 0; }
    #meterCanvas { height: 50px; }
    #bottomBar { padding: 2px 4px; }
    .softBtn { height: 34px; font-size: 11px; }
}
@media (max-width: 480px) and (orientation: landscape) {
    #freqDisplay { height: 32px; }
    #freqDisplay .freq-digit { width: 32px; height: 32px; background-size: 332px 32px; }
    #freqDisplay .freq-digit.digit-0 { background-position: 0px 0; }
    #freqDisplay .freq-digit.digit-1 { background-position: -32px 0; }
    #freqDisplay .freq-digit.digit-2 { background-position: -66px 0; }
    #freqDisplay .freq-digit.digit-3 { background-position: -97px 0; }
    #freqDisplay .freq-digit.digit-4 { background-position: -130px 0; }
    #freqDisplay .freq-digit.digit-5 { background-position: -162px 0; }
    #freqDisplay .freq-digit.digit-6 { background-position: -195px 0; }
    #freqDisplay .freq-digit.digit-7 { background-position: -227px 0; }
    #freqDisplay .freq-digit.digit-8 { background-position: -260px 0; }
    #freqDisplay .freq-digit.digit-9 { background-position: -292px 0; }
    #freqDisplay .freq-digit.digit-dot { width: 7px; background-position: -325px 0; }
    #meterSection { flex: 0 0 35%; }
}
@media (orientation: portrait) {
    #radio {
        max-width: 100%;
        grid-template-rows: 32px 72px 18px 1fr 46px;
    }
    #freqDisplay { height: 17px; }
    #freqDisplay .freq-digit { width: 17px; height: 17px; background-size: 179px 17px; }
    #freqDisplay .freq-digit.digit-0 { background-position: 0px 0; }
    #freqDisplay .freq-digit.digit-1 { background-position: -17px 0; }
    #freqDisplay .freq-digit.digit-2 { background-position: -36px 0; }
    #freqDisplay .freq-digit.digit-3 { background-position: -52px 0; }
    #freqDisplay .freq-digit.digit-4 { background-position: -70px 0; }
    #freqDisplay .freq-digit.digit-5 { background-position: -87px 0; }
    #freqDisplay .freq-digit.digit-6 { background-position: -105px 0; }
    #freqDisplay .freq-digit.digit-7 { background-position: -122px 0; }
    #freqDisplay .freq-digit.digit-8 { background-position: -140px 0; }
    #freqDisplay .freq-digit.digit-9 { background-position: -157px 0; }
    #freqDisplay .freq-digit.digit-dot { width: 4px; background-position: -175px 0; }
    #meterSection { flex: 0 0 40%; }
    #meterCanvas { height: 54px; }
}
</style>
</head>
<body>
<div id="radio">
    <!-- Row 1: Top bar -->
    <div id="topBar">
        <span id="txIndicator">RX</span>
        <span id="tuneLabel">TUNE</span>
        <button id="modeBtn" onclick="setPanel('mode')">---</button>
        <span id="pbBars"><i></i><i></i></span>
        <span id="filterText">FIL1</span>
        <span id="dspIndicators"></span>
        <span class="flex-space"></span>
        <span id="clock">--:--</span>
        <span id="connDot" title="Disconnected"></span>
    </div>

    <!-- Row 2: Meter + Frequency -->
    <div id="meterFreqRow">
        <div id="meterSection">
            <canvas id="meterCanvas" width="500" height="128"></canvas>
        </div>
        <div id="freqSection">
            <div id="vfoLine">
                <span id="vfoLabel">VFO A</span>
                <span id="vfoNum">1</span>
                <span id="splitBadge" class="hidden">SPLIT</span>
                <span id="splitFreq" class="hidden"></span>
            </div>
            <div id="freqDisplay" tabindex="0"></div>
        </div>
    </div>

    <!-- Row 3: Scope info bar -->
    <div id="scopeInfoBar">
        <span id="spanIndicator" onclick="setPanel('span')"></span>
        <span id="scopeLabel">SPECTRUM SCOPE</span>
        <span id="otherVfoFreq">---.---.---</span>
    </div>

    <!-- Row 4: Scope + overlays -->
    <div id="scopeArea">
        <canvas id="spectrumCanvas" width="800" height="150"></canvas>
        <canvas id="waterfallCanvas" width="800" height="200"></canvas>
        <span id="spanEdgeLeft"></span>
        <span id="spanEdgeRight"></span>

        <!-- Mode overlay -->
        <div id="modeOverlay" class="overlay">
            <div class="overlay-title">MODE</div>
            <div class="overlay-grid" id="modeGrid"></div>
        </div>

        <!-- Band overlay -->
        <div id="bandOverlay" class="overlay">
            <div class="overlay-title">BAND STACKING REGISTER</div>
            <div class="overlay-grid" id="bandGrid"></div>
        </div>

        <!-- Function overlay -->
        <div id="funcOverlay" class="overlay">
            <div class="overlay-title">FUNCTION</div>
            <div class="overlay-grid" id="funcGrid"></div>
        </div>

        <!-- Span overlay -->
        <div id="spanOverlay" class="overlay">
            <div class="overlay-title">SPAN</div>
            <div class="overlay-grid" id="spanGrid"></div>
        </div>

        <!-- CW Bar (minimal bottom interface) -->
        <div id="cwBar" class="cw-bar hidden">
            <div class="cw-bar-header">
                <span class="cw-label">CW</span>
                <div class="cw-speed-ctrl">
                    <button class="cw-speed-btn" id="cwSpeedDown">−</button>
                    <input type="number" id="cwSpeedInput" min="10" max="35" value="20">
                    <span class="cw-wpm-label">WPM</span>
                    <button class="cw-speed-btn" id="cwSpeedUp">+</button>
                </div>
                <div class="cw-mode-btns">
                    <button class="cw-mode-btn active" data-mode="chars">CHR</button>
                    <button class="cw-mode-btn" data-mode="words">WRD</button>
                    <button class="cw-mode-btn" data-mode="lines">LN</button>
                </div>
                <button id="cwStopBtn" class="cw-stop-btn">STOP</button>
                <button id="cwCloseBtn" class="cw-close-btn">✕</button>
            </div>

            <!-- Macro buttons -->
            <div class="cw-macro-grid" id="cwMacroGrid1"></div>
            <div class="cw-macro-grid" id="cwMacroGrid2"></div>

            <!-- Callsign inputs -->
            <div class="cw-callsign-row">
                <span class="cw-callsign-label">CALL:</span>
                <input type="text" id="cwCallInput" class="cw-callsign-input" maxlength="10" placeholder="">
                <span class="cw-callsign-label">QSO:</span>
                <input type="text" id="cwQsoInput" class="cw-callsign-input" maxlength="10" placeholder="">
            </div>

            <div class="cw-display" id="cwDisplay"></div>
            <input type="text" id="cwInput" class="cw-input-field" placeholder="TYPE CW MESSAGE..." autocomplete="off">
        </div>

        <!-- Macro editor popup -->
        <div id="cwMacroEditor" class="overlay" style="display:none;">
            <div class="editor-dialog">
                <div class="editor-title">Edit Macro Button</div>
                <div class="editor-hint">Use [CALL] and [QSO] as placeholders</div>
                <textarea id="cwMacroText"></textarea>
                <div class="editor-buttons">
                    <button id="cwMacroSave">SAVE</button>
                    <button id="cwMacroClear">CLEAR</button>
                    <button id="cwMacroCancel">CANCEL</button>
                </div>
            </div>
        </div>

        <!-- Gain overlay -->
        <div id="gainOverlay" class="overlay">
            <div class="gain-row">
                <span class="gain-label">AF</span>
                <div class="gain-bar-bg"><div class="gain-bar-fill" id="afGainFill" style="width:50%"></div>
                    <input type="range" id="afGainSlider" min="0" max="255" value="128"></div>
                <span class="gain-val" id="afGainVal">128</span>
            </div>
            <div class="gain-row">
                <span class="gain-label">RF</span>
                <div class="gain-bar-bg"><div class="gain-bar-fill" id="rfGainFill" style="width:50%"></div>
                    <input type="range" id="rfGainSlider" min="0" max="255" value="128"></div>
                <span class="gain-val" id="rfGainVal">128</span>
            </div>
            <div class="gain-row">
                <span class="gain-label">PWR</span>
                <div class="gain-bar-bg"><div class="gain-bar-fill" id="rfPowerFill" style="width:50%"></div>
                    <input type="range" id="rfPowerSlider" min="0" max="255" value="128"></div>
                <span class="gain-val" id="rfPowerVal">128</span>
            </div>
            <div class="gain-row">
                <span class="gain-label">SQL</span>
                <div class="gain-bar-bg"><div class="gain-bar-fill" id="squelchFill" style="width:0%"></div>
                    <input type="range" id="squelchSlider" min="0" max="255" value="0"></div>
                <span class="gain-val" id="squelchVal">0</span>
            </div>
        </div>

        <!-- Freq input overlay -->
        <div id="freqOverlay" class="overlay">
            <div class="overlay-title">F-INP</div>
            <div id="freqInputDisplay">0</div>
            <div id="freqKeypad">
                <button class="key-btn" onclick="freqKey('1')">1</button>
                <button class="key-btn" onclick="freqKey('2')">2</button>
                <button class="key-btn" onclick="freqKey('3')">3</button>
                <button class="key-btn" onclick="freqKey('SPLIT')">SPLIT</button>
                <button class="key-btn" onclick="freqKey('4')">4</button>
                <button class="key-btn" onclick="freqKey('5')">5</button>
                <button class="key-btn" onclick="freqKey('6')">6</button>
                <button class="key-btn" onclick="freqKey('VFO')">VFO</button>
                <button class="key-btn" onclick="freqKey('7')">7</button>
                <button class="key-btn" onclick="freqKey('8')">8</button>
                <button class="key-btn" onclick="freqKey('9')">9</button>
                <button class="key-btn key-ent" onclick="freqKey('ENT')">ENT</button>
                <button class="key-btn" onclick="freqKey('.')">&#x00B7;</button>
                <button class="key-btn" onclick="freqKey('0')">0</button>
                <button class="key-btn" onclick="freqKey('CE')">CE</button>
                <button class="key-btn ov-btn back-btn" onclick="freqKey('BACK')">&#x21A9;</button>
            </div>
        </div>

        <!-- Audio/Mic enable menu -->
        <div id="audioMicOverlay" class="overlay">
            <div class="overlay-title">AUDIO / TX</div>
            <div class="overlay-grid" id="audioMicGrid"></div>
        </div>

        <!-- Warning overlays on spectrum -->
        <div id="audioOffWarning" class="spectrum-warning" onclick="showAudioMicMenu()" style="display: none;">AUDIO OFF</div>
        <div id="micOffWarning" class="spectrum-warning" onclick="showAudioMicMenu()" style="display: none;">MIC OFF</div>
    </div>

    <!-- Row 5: Bottom bar -->
    <div id="bottomBar"></div>
</div>

<script>
// ============================================================
// STATE
// ============================================================
var ws = null;
var currentFreq = 0;
var vfoAFreq = 0;
var vfoBFreq = 0;
var currentMode = '';
var tuneStep = 1000;
var isTransmitting = false;
var isSplit = false;
var reconnectTimer = null;
var defaultModes = ['LSB', 'USB', 'AM', 'CW', 'RTTY', 'FM', 'CW-R', 'RTTY-R'];

var audioCtx = null;
var audioWorkletNode = null;
var audioEnabled = false;
var audioAvailable = false;
var audioSampleRate = 48000;

var micEnabled = false;
var txAudioAvailable = false;
var micStream = null;
var micAudioCtx = null;
var micWorkletNode = null;
var micSeq = 0;

var nbOn = false;
var nrOn = false;
var anfOn = false;
var tunerState = 0;
var currentPreamp = 0;
var currentFilter = 1;

var availableSpans = [];
var currentSpanIndex = -1;

var hasSpectrum = false;
var spectAmpMax = 160;
var spectStartFreq = 0;
var spectEndFreq = 0;
var spectData = null;
var spectDataLen = 0;
var wfImageData = null;
var wfOffCanvas = null;
var wfOffCtx = null;
var spectRenderPending = false;
var colorTable = null;

// UI state
var currentPanel = 'default';
var availableModes = defaultModes.slice();
var availablePreamps = [];
var availableFilters = [];
var currentVfo = 'A';

// Meter state
var meterVal = -54;
var powerVal = 0;
var swrVal = 1.0;

// Freq input
var freqInputBuf = '';

// ============================================================
// WEBSOCKET (preserved)
// ============================================================
function connect() {
    var wsUrl;
    if (location.protocol === 'https:') {
        wsUrl = 'wss://' + location.hostname + ':' + (location.port || '443');
    } else {
        var wsPort = parseInt(location.port || '80') + 1;
        wsUrl = 'ws://' + location.hostname + ':' + wsPort;
    }
    ws = new WebSocket(wsUrl);
    ws.binaryType = 'arraybuffer';

    ws.onopen = function() {
        document.getElementById('connDot').classList.add('connected');
        document.getElementById('connDot').title = 'Connected';
        if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
        send({ cmd: 'getStatus' });
    };
    ws.onclose = function() {
        document.getElementById('connDot').classList.remove('connected');
        document.getElementById('connDot').title = 'Disconnected';
        if (micEnabled) stopMic();
        if (audioEnabled) stopAudio();
        audioAvailable = false;
        txAudioAvailable = false;
        updateWarningVisibility();
        scheduleReconnect();
    };
    ws.onerror = function() {};
    ws.onmessage = function(event) {
        if (event.data instanceof ArrayBuffer) { handleBinaryMessage(event.data); return; }
        try { handleMessage(JSON.parse(event.data)); } catch(e) { console.error('Parse error:', e); }
    };
}

function scheduleReconnect() {
    if (!reconnectTimer) {
        reconnectTimer = setTimeout(function() { reconnectTimer = null; connect(); }, 3000);
    }
}

function send(obj) {
    if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(obj));
}

// ============================================================
// MESSAGE HANDLING
// ============================================================
function handleMessage(msg) {
    switch (msg.type) {
        case 'rigInfo':
            if (msg.connected) {
                if (msg.modes) populateModes(msg.modes);
                if (msg.hasSpectrum) { hasSpectrum = true; spectAmpMax = msg.spectAmpMax || 160; }
                if (msg.audioAvailable) { audioAvailable = true; audioSampleRate = msg.audioSampleRate || 48000; }
                updateTxAudioAvailable(msg.txAudioAvailable || false);
                if (msg.spans) populateSpans(msg.spans);
                if (msg.preamps) populatePreamps(msg.preamps);
                if (msg.filters) populateFilters(msg.filters);
                updateWarningVisibility();
            }
            break;
        case 'rigConnected':
            if (msg.modes) populateModes(msg.modes);
            if (msg.hasSpectrum) { hasSpectrum = true; spectAmpMax = msg.spectAmpMax || 160; }
            if (msg.audioAvailable) { audioAvailable = true; audioSampleRate = msg.audioSampleRate || 48000; }
            updateTxAudioAvailable(msg.txAudioAvailable || false);
            if (msg.spans) populateSpans(msg.spans);
            if (msg.preamps) populatePreamps(msg.preamps);
            if (msg.filters) populateFilters(msg.filters);
            updateWarningVisibility();
            break;
        case 'audioAvailable':
            if (msg.available) { audioAvailable = true; audioSampleRate = msg.sampleRate || 48000; }
            else { audioAvailable = false; if (audioEnabled) stopAudio(); }
            if (msg.txAudioAvailable !== undefined) updateTxAudioAvailable(msg.txAudioAvailable);
            updateWarningVisibility();
            break;
        case 'audioStatus':
            if (msg.enabled) { audioEnabled = true; audioSampleRate = msg.sampleRate || audioSampleRate; }
            else { audioEnabled = false; }
            renderBottomBar();
            updateWarningVisibility();
            if (currentPanel === 'audiomiс') renderAudioMicOverlay();
            break;
        case 'status':
            // Handle VFO-specific frequencies if available
            if (msg.vfoAFrequency !== undefined) vfoAFreq = msg.vfoAFrequency;
            if (msg.vfoBFrequency !== undefined) vfoBFreq = msg.vfoBFrequency;
            // Update display after VFO frequencies are set
            if (msg.vfoAFrequency !== undefined || msg.vfoBFrequency !== undefined) {
                // Determine current VFO frequency for main display
                if (currentVfo === 'A' && msg.vfoAFrequency !== undefined) {
                    updateFrequency(msg.vfoAFrequency);
                } else if (currentVfo === 'B' && msg.vfoBFrequency !== undefined) {
                    updateFrequency(msg.vfoBFrequency);
                } else if (msg.frequency !== undefined) {
                    updateFrequency(msg.frequency);
                }
                updateOtherVfoDisplay();
            } else if (msg.frequency !== undefined) {
                updateFrequency(msg.frequency);
            }
            if (msg.mode !== undefined) updateMode(msg.mode);
            if (msg.filter !== undefined) updateFilterBtn(msg.filter);
            if (msg.sMeter !== undefined) updateSMeter(msg.sMeter);
            if (msg.transmitting !== undefined) updateTxStatus(msg.transmitting);
            if (msg.afGain !== undefined) updateSlider('afGain', msg.afGain);
            if (msg.rfGain !== undefined) updateSlider('rfGain', msg.rfGain);
            if (msg.rfPower !== undefined) updateSlider('rfPower', msg.rfPower);
            if (msg.squelch !== undefined) updateSlider('squelch', msg.squelch);
            if (msg.split !== undefined) updateSplit(msg.split);
            if (msg.spanIndex !== undefined) updateSpanIndex(msg.spanIndex);
            if (msg.nb !== undefined) updateToggle('nb', msg.nb);
            if (msg.nr !== undefined) updateToggle('nr', msg.nr);
            if (msg.autoNotch !== undefined) updateToggle('anf', msg.autoNotch);
            if (msg.tuner !== undefined) updateTunerState(msg.tuner);
            if (msg.preamp !== undefined) updatePreampBtn(msg.preamp);
            if (msg.filterWidth !== undefined) updateSlider('filterWidth', msg.filterWidth);
            break;
        case 'update':
            // Handle VFO-specific frequencies if available
            if (msg.vfoAFrequency !== undefined) vfoAFreq = msg.vfoAFrequency;
            if (msg.vfoBFrequency !== undefined) vfoBFreq = msg.vfoBFrequency;
            // Update display after VFO frequencies are set
            if (msg.vfoAFrequency !== undefined || msg.vfoBFrequency !== undefined) {
                // Determine current VFO frequency for main display
                if (currentVfo === 'A' && msg.vfoAFrequency !== undefined) {
                    updateFrequency(msg.vfoAFrequency);
                } else if (currentVfo === 'B' && msg.vfoBFrequency !== undefined) {
                    updateFrequency(msg.vfoBFrequency);
                } else if (msg.frequency !== undefined) {
                    updateFrequency(msg.frequency);
                }
                updateOtherVfoDisplay();
            } else if (msg.frequency !== undefined) {
                updateFrequency(msg.frequency);
            }
            if (msg.mode !== undefined) updateMode(msg.mode);
            if (msg.filter !== undefined) updateFilterBtn(msg.filter);
            if (msg.sMeter !== undefined) updateSMeter(msg.sMeter);
            if (msg.powerMeter !== undefined) updatePowerMeter(msg.powerMeter);
            if (msg.swrMeter !== undefined) updateSwrMeter(msg.swrMeter);
            if (msg.transmitting !== undefined) updateTxStatus(msg.transmitting);
            if (msg.afGain !== undefined) updateSlider('afGain', msg.afGain);
            if (msg.rfGain !== undefined) updateSlider('rfGain', msg.rfGain);
            if (msg.rfPower !== undefined) updateSlider('rfPower', msg.rfPower);
            if (msg.squelch !== undefined) updateSlider('squelch', msg.squelch);
            if (msg.split !== undefined) updateSplit(msg.split);
            if (msg.spanIndex !== undefined) updateSpanIndex(msg.spanIndex);
            if (msg.nb !== undefined) updateToggle('nb', msg.nb);
            if (msg.nr !== undefined) updateToggle('nr', msg.nr);
            if (msg.autoNotch !== undefined) updateToggle('anf', msg.autoNotch);
            if (msg.tuner !== undefined) updateTunerState(msg.tuner);
            if (msg.preamp !== undefined) updatePreampBtn(msg.preamp);
            if (msg.filterWidth !== undefined) updateSlider('filterWidth', msg.filterWidth);
            break;
        case 'meters':
            if (msg.sMeter !== undefined) updateSMeter(msg.sMeter);
            if (msg.powerMeter !== undefined) updatePowerMeter(msg.powerMeter);
            if (msg.swrMeter !== undefined) updateSwrMeter(msg.swrMeter);
            break;
        case 'error':
            console.error('Server error:', msg.message);
            break;
    }
}

// ============================================================
// UI UPDATES
// ============================================================
function updateFrequency(hz) {
    currentFreq = hz;

    // Store frequency for current VFO only
    if (currentVfo === 'A') {
        vfoAFreq = hz;
    } else {
        vfoBFreq = hz;
    }

    // Update main frequency display with sprite-based digits
    var mhz = Math.floor(hz / 1000000);
    var khz = Math.floor((hz % 1000000) / 1000);
    var hzPart = hz % 1000;

    var freqStr = String(mhz) + '.' +
                  String(khz).padStart(3, '0') + '.' +
                  String(hzPart).padStart(3, '0');

    var d = document.getElementById('freqDisplay');
    d.innerHTML = '';

    for (var i = 0; i < freqStr.length; i++) {
        var char = freqStr[i];
        var span = document.createElement('span');
        span.className = 'freq-digit digit-' + (char === '.' ? 'dot' : char);
        d.appendChild(span);
    }

    // Update other VFO frequency display
    updateOtherVfoDisplay();
}

function updateOtherVfoDisplay() {
    var otherFreq = (currentVfo === 'A') ? vfoBFreq : vfoAFreq;
    if (otherFreq > 0) {
        var mhz = Math.floor(otherFreq / 1000000);
        var khz = Math.floor((otherFreq % 1000000) / 1000);
        var hz = otherFreq % 1000;
        var displayText = mhz + '.' + String(khz).padStart(3, '0') + '.' + String(hz).padStart(3, '0');
        document.getElementById('otherVfoFreq').textContent = displayText;
    } else {
        document.getElementById('otherVfoFreq').textContent = '---.---.---';
    }
}

function updateMode(mode) {
    currentMode = mode;
    document.getElementById('modeBtn').textContent = mode;
    if (currentPanel === 'mode') renderModeOverlay();

    // Hide CW bar if switching to non-CW mode
    var isCW = (mode === 'CW' || mode === 'CW-R');
    if (!isCW) {
        document.getElementById('cwBar').classList.add('hidden');
    }

    renderBottomBar(); // Update PTT/KEY button
}

function updateFilterBtn(num) {
    currentFilter = num;
    document.getElementById('filterText').textContent = 'FIL' + num;
    if (currentPanel === 'func') renderFuncOverlay();
}

function updateTxStatus(tx) {
    isTransmitting = tx;
    var ind = document.getElementById('txIndicator');
    ind.textContent = tx ? 'TX' : 'RX';
    ind.classList.toggle('tx', tx);
    drawMeter();
    renderBottomBar();
}

function updateSplit(on) {
    isSplit = on;
    document.getElementById('splitBadge').classList.toggle('hidden', !on);
}

function updateToggle(name, state) {
    if (name === 'nb') nbOn = !!state;
    else if (name === 'nr') nrOn = !!state;
    else if (name === 'anf') anfOn = !!state;
    updateDspIndicators();
    if (currentPanel === 'func') renderFuncOverlay();
}

function updateTunerState(val) {
    tunerState = val;
    var lbl = document.getElementById('tuneLabel');
    lbl.classList.toggle('active', val > 0);
    lbl.classList.toggle('tuning', val === 2);
    if (currentPanel === 'func') renderFuncOverlay();
}

function updatePreampBtn(num) {
    currentPreamp = num;
    if (currentPanel === 'func') renderFuncOverlay();
}

function updateDspIndicators() {
    var el = document.getElementById('dspIndicators');
    var tags = [];
    if (nbOn) tags.push('NB');
    if (nrOn) tags.push('NR');
    if (anfOn) tags.push('ANF');
    el.innerHTML = tags.map(function(t) { return '<span class="dsp-tag">' + t + '</span>'; }).join('');
}

// Slider system
var sliderSetTimes = {};
var sliderDragging = {};
var SLIDER_DEBOUNCE_MS = 1500;

function initSliderTracking() {
    ['afGain', 'rfGain', 'rfPower', 'squelch'].forEach(function(name) {
        var slider = document.getElementById(name + 'Slider');
        if (!slider) return;
        slider.addEventListener('mousedown', function() { sliderDragging[name] = true; });
        slider.addEventListener('touchstart', function() { sliderDragging[name] = true; });
        slider.addEventListener('mouseup', function() { sliderDragging[name] = false; });
        slider.addEventListener('touchend', function() { sliderDragging[name] = false; });
        slider.addEventListener('mouseleave', function() { sliderDragging[name] = false; });
        slider.addEventListener('touchcancel', function() { sliderDragging[name] = false; });
        slider.addEventListener('input', function() {
            var val = slider.value;
            sliderSetTimes[name] = Date.now();
            document.getElementById(name + 'Val').textContent = val;
            var fill = document.getElementById(name.replace(/([A-Z])/g, function(m) { return m; }) + 'Fill');
            if (fill) fill.style.width = (val / 255 * 100) + '%';
            if (name === 'afGain') throttledSend('afGain', 'setAfGain', val);
            else if (name === 'rfGain') throttledSend('rfGain', 'setRfGain', val);
            else if (name === 'rfPower') throttledSend('rfPower', 'setRfPower', val);
            else if (name === 'squelch') throttledSend('squelch', 'setSquelch', val);
        });
    });
}

function updateSlider(name, val) {
    if (sliderDragging[name]) return;
    if ((Date.now() - (sliderSetTimes[name] || 0)) < SLIDER_DEBOUNCE_MS) return;
    var slider = document.getElementById(name + 'Slider');
    var valSpan = document.getElementById(name + 'Val');
    if (slider) slider.value = val;
    if (valSpan) valSpan.textContent = val;
    // Update fill bars
    var fillId = name + 'Fill';
    var fill = document.getElementById(fillId);
    if (fill) fill.style.width = (val / 255 * 100) + '%';
}

var sliderTimers = {};
function throttledSend(name, cmd, val) {
    if (sliderTimers[name]) clearTimeout(sliderTimers[name]);
    sliderTimers[name] = setTimeout(function() { send({ cmd: cmd, value: parseInt(val) }); }, 50);
}

function populateModes(modes) { availableModes = modes; if (currentPanel === 'mode') renderModeOverlay(); }
function populateSpans(spans) { availableSpans = spans; }
function populatePreamps(preamps) { availablePreamps = preamps || []; }
function populateFilters(filters) { availableFilters = filters || []; }
function updateSpanIndex(idx) {
    currentSpanIndex = idx;
    if (currentPanel === 'span') renderSpanOverlay();
    // Update span indicator
    var spanText = 'SPAN';
    if (idx >= 0 && idx < availableSpans.length) {
        spanText = availableSpans[idx].name;
    }
    document.getElementById('spanIndicator').textContent = spanText;
}

// ============================================================
// CANVAS S-METER (IC-7300 segmented style)
// ============================================================
// IC-7300 S-meter constants
// Segment layout: 21 segs for S0-S9, 14 segs for S9+ (total 35)
var METER_SEGS = 35;
var METER_S9_SEG = 21;
// IC-7300 colors
var METER_BLUE = '#4488cc';     // segments below S9
var METER_RED  = '#cc2222';     // segments above S9
var METER_DARK = '#1c1c1c';     // inactive segment
var METER_BASELINE = '#999';    // thin white line under segments

function updateSMeter(val) { meterVal = val; if (!isTransmitting) drawMeter(); }
function updatePowerMeter(val) { powerVal = val; if (isTransmitting) drawMeter(); }
function updateSwrMeter(val) { swrVal = val; if (isTransmitting) drawMeter(); }

function drawMeter() {
    var canvas = document.getElementById('meterCanvas');
    var dpr = window.devicePixelRatio || 1;
    var cssW = canvas.clientWidth;
    var cssH = canvas.clientHeight;
    if (cssW === 0) return;

    if (canvas.width !== Math.round(cssW * dpr) || canvas.height !== Math.round(cssH * dpr)) {
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
    }
    var ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, cssW, cssH);
    var cw = cssW, ch = cssH;

    // --- Shared geometry ---
    // "S/SWR" label on the left takes ~30px
    var labelW = 30;
    var barX = labelW + 2;                     // where segments start
    var barW = cw - barX - 2;                  // total width for segments
    var segGap = Math.max(1, Math.round(barW * 0.004));
    var segW  = (barW - (METER_SEGS - 1) * segGap) / METER_SEGS;
    if (segW < 2) { segW = 2; segGap = 1; }

    // Helper: x position of segment n
    function segX(n) { return barX + n * (segW + segGap); }

    if (!isTransmitting) {
        drawSMeter(ctx, cw, ch, barX, barW, segW, segGap, segX, labelW);
    } else {
        drawTxMeters(ctx, cw, ch, barX, barW, segW, segGap, segX, labelW);
    }

    ctx.setTransform(1, 0, 0, 1, 0, 0);
}

function drawSMeter(ctx, cw, ch, barX, barW, segW, segGap, segX, labelW) {
    // Layout: scale row at top, tick marks, segments, white baseline, value text
    var scaleY  = 1;       // top of scale numbers
    var tickY   = 14;      // tick mark top
    var tickH   = 3;
    var segY    = 20;      // top of segment bar
    var segH    = ch - segY - 14;  // leave room for value text at bottom
    if (segH < 10) segH = 10;
    var baseY   = segY + segH;     // white baseline

    // --- "S/SWR" label (left side, two lines) ---
    ctx.fillStyle = '#888';
    ctx.font = '9px system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText('S', 2, scaleY);
    ctx.fillStyle = '#666';
    ctx.fillText('SWR', 2, scaleY + 11);

    // --- Scale labels (above segments) ---
    // S-unit labels: 1, 3, 5, 7, 9 – positioned at their segment
    // Each S-unit = METER_S9_SEG/9 segments
    var sPerUnit = METER_S9_SEG / 9;
    var sLabels = [
        { text: '1', seg: 1 * sPerUnit },
        { text: '3', seg: 3 * sPerUnit },
        { text: '5', seg: 5 * sPerUnit },
        { text: '7', seg: 7 * sPerUnit },
        { text: '9', seg: 9 * sPerUnit }
    ];
    ctx.font = 'bold 9px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#ccc';
    for (var i = 0; i < sLabels.length; i++) {
        var lx = segX(Math.round(sLabels[i].seg));
        ctx.fillText(sLabels[i].text, lx, scaleY);
    }

    // +dB labels in red: +20, +40, +60dB
    var dbPerSeg = 60 / (METER_SEGS - METER_S9_SEG);  // dB per segment in S9+ zone
    var dbLabels = [
        { text: '+20', seg: METER_S9_SEG + Math.round(20 / dbPerSeg) },
        { text: '+40', seg: METER_S9_SEG + Math.round(40 / dbPerSeg) },
        { text: '+60dB', seg: METER_SEGS - 1 }
    ];
    ctx.fillStyle = '#cc4444';
    for (var j = 0; j < dbLabels.length; j++) {
        var dx = segX(Math.round(dbLabels[j].seg));
        ctx.fillText(dbLabels[j].text, dx, scaleY);
    }

    // --- Tick marks (small vertical lines below scale numbers) ---
    ctx.fillStyle = '#666';
    // Ticks at every S-unit position (1-9)
    for (var t = 1; t <= 9; t++) {
        var tx = segX(Math.round(t * sPerUnit));
        ctx.fillRect(Math.round(tx) - 0.5, tickY, 1, tickH);
    }
    // Ticks at +20, +40, +60
    for (var dt = 0; dt < dbLabels.length; dt++) {
        var dtx = segX(Math.round(dbLabels[dt].seg));
        ctx.fillStyle = '#884444';
        ctx.fillRect(Math.round(dtx) - 0.5, tickY, 1, tickH);
    }
    // Small dots between major ticks (every other segment)
    ctx.fillStyle = '#333';
    for (var dot = 0; dot < METER_SEGS; dot += 2) {
        var dotx = segX(dot) + segW / 2;
        ctx.fillRect(Math.round(dotx), tickY + 1, 1, 1);
    }

    // --- Calculate fill level ---
    var fillCount = 0;
    if (meterVal <= 0) {
        // -54 (S0) → 0 segs, 0 (S9) → METER_S9_SEG segs
        fillCount = Math.round(((meterVal + 54) / 54) * METER_S9_SEG);
    } else {
        // 0 (S9) → S9_SEG, 60 (S9+60) → METER_SEGS
        fillCount = METER_S9_SEG + Math.round(Math.min(60, meterVal) / 60 * (METER_SEGS - METER_S9_SEG));
    }
    fillCount = Math.max(0, Math.min(METER_SEGS, fillCount));

    // --- Draw segment bar ---
    for (var s = 0; s < METER_SEGS; s++) {
        var sx = segX(s);
        if (s < fillCount) {
            ctx.fillStyle = (s < METER_S9_SEG) ? METER_BLUE : METER_RED;
        } else {
            ctx.fillStyle = METER_DARK;
        }
        ctx.fillRect(sx, segY, segW, segH);
    }

    // --- White baseline under segments (IC-7300 distinctive feature) ---
    ctx.fillStyle = METER_BASELINE;
    ctx.fillRect(barX, baseY, barW, 1);

    // --- S-value readout (bottom-left) ---
    var label;
    if (meterVal <= 0) {
        var sUnit = Math.max(0, (meterVal + 54) / 6);
        label = sUnit >= 9 ? 'S9' : 'S' + Math.floor(Math.min(9, sUnit));
    } else {
        label = 'S9+' + Math.round(meterVal) + 'dB';
    }
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';
    ctx.fillText(label, 2, ch - 1);
}

function drawTxMeters(ctx, cw, ch, barX, barW, segW, segGap, segX, labelW) {
    // TX mode: S/Po bar on top, SWR bar on bottom (matching IC-7300 "S/Po" display)
    var gap = 4;
    var meterH = Math.floor((ch - gap) / 2);

    // === Po meter (top half) ===
    drawSegBar(ctx, {
        x: barX, y: 0, w: barW, h: meterH,
        label: 'Po', labelX: 2,
        scaleLabels: [
            { text: '0', frac: 0 },
            { text: '25', frac: 0.25 },
            { text: '50', frac: 0.50 },
            { text: '100%', frac: 1.0 }
        ],
        fillFrac: Math.min(1, powerVal / 100),
        fillColor: METER_BLUE,
        warnColor: METER_RED,
        warnFrac: 1.0,  // no warning zone for Po
        valueText: Math.round(powerVal) + 'W',
        segW: segW, segGap: segGap, segX: segX
    });

    // === SWR meter (bottom half) ===
    var swrY = meterH + gap;
    // SWR scale is non-linear: 1.0-1.5-2-3 compressed on left
    var swrFrac = Math.min(1, Math.max(0, (swrVal - 1.0) / 5.0));
    drawSegBar(ctx, {
        x: barX, y: swrY, w: barW, h: meterH,
        label: 'SWR', labelX: 2,
        scaleLabels: [
            { text: '1', frac: 0 },
            { text: '1.5', frac: 0.1 },
            { text: '2', frac: 0.2 },
            { text: '3', frac: 0.4 }
        ],
        fillFrac: swrFrac,
        fillColor: METER_BLUE,
        warnColor: METER_RED,
        warnFrac: 0.2,  // SWR > 2.0 → red
        valueText: swrVal.toFixed(1),
        segW: segW, segGap: segGap, segX: segX
    });
}

// Generic segmented meter bar (used for Po, SWR in TX mode)
function drawSegBar(ctx, o) {
    var scaleY = o.y + 1;
    var segY = o.y + 14;
    var segH = o.h - 16;
    if (segH < 6) segH = 6;
    var baseY = segY + segH;

    // Label
    ctx.fillStyle = '#888';
    ctx.font = 'bold 9px system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(o.label, o.labelX, scaleY);

    // Scale labels
    ctx.fillStyle = '#888';
    ctx.font = '8px system-ui, sans-serif';
    ctx.textAlign = 'center';
    for (var i = 0; i < o.scaleLabels.length; i++) {
        var sl = o.scaleLabels[i];
        var lx = o.segX(Math.round(sl.frac * (METER_SEGS - 1)));
        ctx.fillText(sl.text, lx, scaleY);
    }

    // Value text (right side)
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    ctx.fillText(o.valueText, o.x + o.w, scaleY);

    // Segments
    var fillCount = Math.round(o.fillFrac * METER_SEGS);
    fillCount = Math.max(0, Math.min(METER_SEGS, fillCount));
    var warnSeg = Math.round(o.warnFrac * METER_SEGS);

    for (var s = 0; s < METER_SEGS; s++) {
        var sx = o.segX(s);
        if (s < fillCount) {
            ctx.fillStyle = (s >= warnSeg) ? o.warnColor : o.fillColor;
        } else {
            ctx.fillStyle = METER_DARK;
        }
        ctx.fillRect(sx, segY, o.segW, segH);
    }

    // White baseline
    ctx.fillStyle = METER_BASELINE;
    ctx.fillRect(o.x, baseY, o.w, 1);
}

// ============================================================
// BOTTOM BAR + PANEL SYSTEM
// ============================================================

function setPanel(name) {
    hideAllOverlays();
    currentPanel = name;
    // Show relevant overlay
    if (name === 'mode') renderModeOverlay();
    else if (name === 'band') renderBandOverlay();
    else if (name === 'func') renderFuncOverlay();
    else if (name === 'audiomiс') renderAudioMicOverlay();
    else if (name === 'gain') document.getElementById('gainOverlay').classList.add('visible');
    else if (name === 'scope') {}
    else if (name === 'span') renderSpanOverlay();
    else if (name === 'freqinp') renderFreqInput();
    else if (name === 'cw') renderCWOverlay();
    renderBottomBar();
}

function hideAllOverlays() {
    var overlays = document.querySelectorAll('.overlay');
    for (var i = 0; i < overlays.length; i++) overlays[i].classList.remove('visible');
}

function renderBottomBar() {
    var bar = document.getElementById('bottomBar');
    bar.innerHTML = '';
    var btns = getBottomButtons();
    for (var i = 0; i < btns.length; i++) {
        var b = btns[i];
        var el = document.createElement('button');
        el.className = 'softBtn';
        if (b.active) el.classList.add('active');
        if (b.txActive) el.classList.add('tx-active');
        if (b.cls) el.classList.add(b.cls);
        el.textContent = b.label;
        if (b.action) el.onclick = b.action;
        bar.appendChild(el);
    }
}

function getBottomButtons() {
    var isCW = (currentMode === 'CW' || currentMode === 'CW-R');

    switch (currentPanel) {
        case 'default':
        case 'mode':
        case 'band':
        case 'func':
            return [
                { label: 'MODE', action: function() { setPanel('mode'); } },
                { label: 'BAND', action: function() { setPanel('band'); } },
                { label: 'FUNC', action: function() { setPanel('func'); } },
                { label: 'GAIN', action: function() { setPanel('gain'); } },
                { label: isCW ? 'KEY' : 'PTT', txActive: isTransmitting, cls: isCW ? 'key-btn' : 'ptt-btn', action: isCW ? toggleCWBar : function() { handlePTTPress(); } }
            ];
        case 'audiomiс':
        case 'span':
        case 'freqinp':
            return [
                { label: '\u23CE', action: function() { setPanel('default'); } }
            ];
        case 'gain':
            return [
                { label: 'VFO A', active: currentVfo === 'A', action: function() { selectVFO('A'); } },
                { label: 'VFO B', active: currentVfo === 'B', action: function() { selectVFO('B'); } },
                { label: 'A/B', action: function() { swapVFO(); } },
                { label: 'SPLIT', active: isSplit, action: function() { toggleSplit(); } },
                { label: '\u23CE', action: function() { hideAllOverlays(); setPanel('default'); } }
            ];
        default:
            return [{ label: '\u23CE', action: function() { setPanel('default'); } }];
    }
}

// --- Overlay renderers ---

function renderModeOverlay() {
    var grid = document.getElementById('modeGrid');
    grid.innerHTML = '';
    for (var i = 0; i < availableModes.length; i++) {
        var btn = document.createElement('button');
        btn.className = 'ov-btn' + (availableModes[i] === currentMode ? ' active' : '');
        btn.textContent = availableModes[i];
        btn.onclick = (function(m) { return function() { setMode(m); setPanel('default'); }; })(availableModes[i]);
        grid.appendChild(btn);
    }
    // Back button
    var back = document.createElement('button');
    back.className = 'ov-btn back-btn';
    back.innerHTML = '&#x21A9;';
    back.onclick = function() { setPanel('default'); };
    grid.appendChild(back);
    document.getElementById('modeOverlay').classList.add('visible');
}

function renderBandOverlay() {
    var grid = document.getElementById('bandGrid');
    grid.innerHTML = '';
    var bands = [
        { label: '1.8', freq: 1800000 },
        { label: '3.5', freq: 3500000 },
        { label: '7', freq: 7000000 },
        { label: 'F-INP', action: 'freqinp' },
        { label: '10', freq: 10100000 },
        { label: '14', freq: 14000000 },
        { label: '18', freq: 18068000 },
        { label: '', freq: 0 },
        { label: '21', freq: 21000000 },
        { label: '24', freq: 24890000 },
        { label: '28', freq: 28000000 },
        { label: '', freq: 0 },
        { label: '50', freq: 50000000 },
        { label: 'GENE', freq: 500000 },
        { label: '', freq: 0 }
    ];
    for (var i = 0; i < bands.length; i++) {
        var b = bands[i];
        var btn = document.createElement('button');
        btn.className = 'ov-btn';
        btn.textContent = b.label;
        if (!b.label) { btn.style.visibility = 'hidden'; }
        else if (b.action === 'freqinp') {
            btn.onclick = function() { setPanel('freqinp'); };
        } else if (b.freq > 0) {
            btn.onclick = (function(f) { return function() {
                send({ cmd: 'setFrequency', value: f });
                setPanel('default');
            }; })(b.freq);
        }
        grid.appendChild(btn);
    }
    // Back button
    var back = document.createElement('button');
    back.className = 'ov-btn back-btn';
    back.innerHTML = '&#x21A9;';
    back.onclick = function() { setPanel('default'); };
    grid.appendChild(back);
    document.getElementById('bandOverlay').classList.add('visible');
}

function renderFuncOverlay() {
    var grid = document.getElementById('funcGrid');
    grid.innerHTML = '';

    // Preamp button
    var preampLabel = 'P.AMP';
    var preampState = 'OFF';
    if (currentPreamp > 0 && availablePreamps.length > 0) {
        for (var p = 0; p < availablePreamps.length; p++) {
            if (availablePreamps[p].num === currentPreamp) { preampState = availablePreamps[p].name; break; }
        }
    }
    var preBtn = makeFuncBtn(preampLabel, preampState, currentPreamp > 0, function() { cyclePreamp(); });
    grid.appendChild(preBtn);

    // Tuner button
    var tunerLabel = 'TUNER';
    var tunerStateStr = tunerState === 0 ? 'OFF' : (tunerState === 2 ? 'TUNING' : 'ON');
    grid.appendChild(makeFuncBtn(tunerLabel, tunerStateStr, tunerState > 0, handleTunerPress));

    // ANF
    grid.appendChild(makeFuncBtn('NOTCH', anfOn ? 'ON' : 'OFF', anfOn, function() {
        send({ cmd: 'setAutoNotch', value: !anfOn });
    }));

    // NB
    grid.appendChild(makeFuncBtn('NB', nbOn ? 'ON' : 'OFF', nbOn, function() {
        send({ cmd: 'setNoiseBlanker', value: !nbOn });
    }));

    // NR
    grid.appendChild(makeFuncBtn('NR', nrOn ? 'ON' : 'OFF', nrOn, function() {
        send({ cmd: 'setNoiseReduction', value: !nrOn });
    }));

    // Second row: Filter buttons
    var filters = availableFilters.length > 0 ? availableFilters : [
        { name: 'FIL1', num: 1 }, { name: 'FIL2', num: 2 }, { name: 'FIL3', num: 3 }
    ];
    for (var f = 0; f < filters.length; f++) {
        var fbtn = document.createElement('button');
        fbtn.className = 'ov-btn' + (currentFilter === filters[f].num ? ' active' : '');
        fbtn.textContent = filters[f].name;
        fbtn.onclick = (function(n) { return function() { send({ cmd: 'setFilter', value: n }); }; })(filters[f].num);
        grid.appendChild(fbtn);
    }

    // Fill remaining slots + back
    var total = grid.children.length;
    var cols = 5;
    var targetSlots = Math.ceil(total / cols) * cols;
    while (grid.children.length < targetSlots - 1) {
        var empty = document.createElement('button');
        empty.className = 'ov-btn';
        empty.style.visibility = 'hidden';
        grid.appendChild(empty);
    }

    var back = document.createElement('button');
    back.className = 'ov-btn back-btn';
    back.innerHTML = '&#x21A9;';
    back.onclick = function() { setPanel('default'); };
    grid.appendChild(back);

    document.getElementById('funcOverlay').classList.add('visible');
}

function makeFuncBtn(label, state, active, onclick) {
    var btn = document.createElement('button');
    btn.className = 'ov-btn' + (active ? ' active' : '');
    btn.innerHTML = '<span class="btn-label">' + label + '</span><span class="btn-state">' + state + '</span>';
    btn.onclick = onclick;
    return btn;
}

function renderAudioMicOverlay() {
    var grid = document.getElementById('audioMicGrid');
    grid.innerHTML = '';

    // RX Audio button
    if (audioAvailable) {
        grid.appendChild(makeFuncBtn('RX AUDIO', audioEnabled ? 'ON' : 'OFF', audioEnabled, function() {
            if (audioEnabled) stopAudio(); else startAudio();
        }));
    }

    // TX Audio (Mic) button
    if (txAudioAvailable && window.isSecureContext) {
        grid.appendChild(makeFuncBtn('TX AUDIO', micEnabled ? 'ON' : 'OFF', micEnabled, function() {
            if (micEnabled) stopMic(); else startMic();
        }));
    }

    // Fill remaining slots + back
    var total = grid.children.length;
    var cols = 5;
    var targetSlots = Math.ceil(total / cols) * cols;
    while (grid.children.length < targetSlots - 1) {
        var empty = document.createElement('button');
        empty.className = 'ov-btn';
        empty.style.visibility = 'hidden';
        grid.appendChild(empty);
    }

    var back = document.createElement('button');
    back.className = 'ov-btn back-btn';
    back.innerHTML = '&#x21A9;';
    back.onclick = function() { setPanel('default'); };
    grid.appendChild(back);

    document.getElementById('audioMicOverlay').classList.add('visible');
}

function cyclePreamp() {
    if (availablePreamps.length === 0) return;
    var idx = -1;
    for (var i = 0; i < availablePreamps.length; i++) {
        if (availablePreamps[i].num === currentPreamp) { idx = i; break; }
    }
    var next = (idx + 1) % availablePreamps.length;
    send({ cmd: 'setPreamp', value: availablePreamps[next].num });
}

function renderSpanOverlay() {
    var grid = document.getElementById('spanGrid');
    grid.innerHTML = '';
    for (var i = 0; i < availableSpans.length; i++) {
        var btn = document.createElement('button');
        btn.className = 'ov-btn' + (i === currentSpanIndex ? ' active' : '');
        btn.textContent = availableSpans[i].name;
        btn.onclick = (function(idx) { return function() { setSpan(idx); setPanel('default'); }; })(i);
        grid.appendChild(btn);
    }
    var back = document.createElement('button');
    back.className = 'ov-btn back-btn';
    back.innerHTML = '&#x21A9;';
    back.onclick = function() { setPanel('scope'); };
    grid.appendChild(back);
    document.getElementById('spanOverlay').classList.add('visible');
}

// Freq input keypad
function renderFreqInput() {
    freqInputBuf = '';
    document.getElementById('freqInputDisplay').textContent = '0';
    document.getElementById('freqOverlay').classList.add('visible');
}

function freqKey(key) {
    if (key === 'BACK') { setPanel('default'); return; }
    if (key === 'CE') { freqInputBuf = ''; document.getElementById('freqInputDisplay').textContent = '0'; return; }
    if (key === 'ENT') {
        var mhz = parseFloat(freqInputBuf);
        if (!isNaN(mhz) && mhz > 0) {
            send({ cmd: 'setFrequency', value: Math.round(mhz * 1000000) });
        }
        setPanel('default');
        return;
    }
    if (key === 'SPLIT') { toggleSplit(); return; }
    if (key === 'VFO') { swapVFO(); return; }
    if (key === '.') {
        if (freqInputBuf.indexOf('.') === -1) freqInputBuf += '.';
    } else {
        freqInputBuf += key;
    }
    document.getElementById('freqInputDisplay').textContent = freqInputBuf || '0';
}

// Tuner handler
function handleTunerPress() {
    send({ cmd: 'setTuner', value: tunerState > 0 ? 0 : 1 });
}

// Audio/Mic menu functions
function showAudioMicMenu() {
    setPanel('audiomiс');
}

function updateWarningVisibility() {
    var audioWarning = document.getElementById('audioOffWarning');
    var micWarning = document.getElementById('micOffWarning');

    // Show audio warning if audio is available but not enabled
    audioWarning.style.display = (audioAvailable && !audioEnabled) ? 'block' : 'none';

    // Show mic warning if TX audio is available but mic is not enabled
    micWarning.style.display = (txAudioAvailable && window.isSecureContext && !micEnabled) ? 'block' : 'none';
}

function handlePTTPress() {
    // Skip audio/mic checks for CW mode (uses radio's internal keyer)
    var isCW = (currentMode === 'CW' || currentMode === 'CW-R');
    if (isCW) return true;

    // Check if audio is off or mic is off (when TX audio is available)
    var audioNeeded = audioAvailable && !audioEnabled;
    var micNeeded = txAudioAvailable && window.isSecureContext && !micEnabled;

    if (audioNeeded || micNeeded) {
        // Don't transmit, show the menu instead
        showAudioMicMenu();
        return false;
    }

    // All checks passed, allow PTT
    return true;
}

// Long-press TUNE in top bar for tuning
(function() {
    var tuneBtn = document.getElementById('tuneLabel');
    var timer = null, longP = false;
    function down(e) { e.preventDefault(); longP = false; timer = setTimeout(function() { longP = true; send({ cmd: 'setTuner', value: 2 }); }, 500); }
    function up(e) { e.preventDefault(); if (timer) { clearTimeout(timer); timer = null; } if (!longP) send({ cmd: 'setTuner', value: tunerState > 0 ? 0 : 1 }); }
    function cancel() { if (timer) { clearTimeout(timer); timer = null; } }
    tuneBtn.addEventListener('mousedown', down); tuneBtn.addEventListener('mouseup', up);
    tuneBtn.addEventListener('mouseleave', cancel); tuneBtn.addEventListener('touchstart', down);
    tuneBtn.addEventListener('touchend', up); tuneBtn.addEventListener('touchcancel', cancel);
    tuneBtn.style.cursor = 'pointer';
})();

// PTT button (hold to transmit)
// PTT with TX audio drain delay
var pttReleaseTimer = null;

function releasePTT() {
    // Cancel any pending release
    if (pttReleaseTimer) {
        clearTimeout(pttReleaseTimer);
    }
    // Wait 300ms to drain TX audio buffer before releasing PTT
    pttReleaseTimer = setTimeout(function() {
        send({ cmd: 'setPTT', value: false });
        pttReleaseTimer = null;
    }, 300);
}

(function() {
    var bar = document.getElementById('bottomBar');
    function isPTT(e) { return e.target.classList.contains('ptt-btn'); }
    function pttOn(e) {
        e.preventDefault();
        if (!handlePTTPress()) return; // Check audio/mic, show menu if needed
        // Cancel any pending PTT release
        if (pttReleaseTimer) {
            clearTimeout(pttReleaseTimer);
            pttReleaseTimer = null;
        }
        flushAudio();
        send({ cmd: 'setPTT', value: true });
    }
    function pttOff(e) { e.preventDefault(); releasePTT(); }
    bar.addEventListener('mousedown', function(e) { if (isPTT(e)) pttOn(e); });
    bar.addEventListener('mouseup', function(e) { if (isPTT(e)) pttOff(e); });
    bar.addEventListener('mouseleave', function() { if (isTransmitting) releasePTT(); });
    bar.addEventListener('touchstart', function(e) { if (isPTT(e)) pttOn(e); });
    bar.addEventListener('touchend', function(e) { if (isPTT(e)) pttOff(e); });
    bar.addEventListener('touchcancel', function() { if (isTransmitting) releasePTT(); });
})();

// ============================================================
// COMMANDS
// ============================================================
function setMode(mode) { send({ cmd: 'setMode', value: mode }); }
function selectVFO(vfo) {
    send({ cmd: 'selectVFO', value: vfo });
    currentVfo = vfo;
    document.getElementById('vfoLabel').textContent = 'VFO ' + vfo;
    renderBottomBar();
    updateOtherVfoDisplay();
}
function swapVFO() {
    send({ cmd: 'swapVFO' });
    // Toggle current VFO tracking
    currentVfo = (currentVfo === 'A') ? 'B' : 'A';
    document.getElementById('vfoLabel').textContent = 'VFO ' + currentVfo;
    updateOtherVfoDisplay();
    renderBottomBar();
}
function equalizeVFO() { send({ cmd: 'equalizeVFO' }); }
function toggleSplit() { send({ cmd: 'setSplit', value: !isSplit }); }
function tuneUp() {
    if (currentFreq > 0) {
        var newFreq = currentFreq + tuneStep;
        // Round down to nearest kHz (reset Hz to 000)
        newFreq = Math.floor(newFreq / 1000) * 1000;
        send({ cmd: 'setFrequency', value: newFreq });
    }
}
function tuneDown() {
    if (currentFreq > tuneStep) {
        var newFreq = currentFreq - tuneStep;
        // Round down to nearest kHz (reset Hz to 000)
        newFreq = Math.floor(newFreq / 1000) * 1000;
        send({ cmd: 'setFrequency', value: newFreq });
    }
}
function tuneUpHz() { if (currentFreq > 0) send({ cmd: 'setFrequency', value: currentFreq + 1 }); }
function tuneDownHz() { if (currentFreq > 1) send({ cmd: 'setFrequency', value: currentFreq - 1 }); }
function setSpan(idx) { send({ cmd: 'setSpan', value: idx }); updateSpanIndex(idx); }

// ============================================================
// AUDIO (preserved)
// ============================================================
var audioRingBuf = null, audioRingWrite = 0, audioRingRead = 0;
var audioRingBuffered = 0, audioRingStarted = false, audioPrebufferSamples = 0;
var audioScriptNode = null, audioUseWorklet = false;

function toggleAudio() {
    if (!audioAvailable) return;
    if (audioEnabled) { stopAudio(); return; }
    startAudio();
}

var audioGainNode = null; // Global gain node for muting RX audio during CW

function startAudio() {
    if (audioCtx) stopAudio();
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: audioSampleRate });
    var bufSize = audioCtx.sampleRate * 1.5; // 1.5s buffer for low-latency LAN
    audioRingBuf = new Float32Array(bufSize);

    // Create gain node for muting during CW
    audioGainNode = audioCtx.createGain();
    audioGainNode.gain.value = 1.0;
    audioGainNode.connect(audioCtx.destination);
    audioRingWrite = 0; audioRingRead = 0; audioRingBuffered = 0;
    audioRingStarted = false;
    audioPrebufferSamples = Math.floor(audioCtx.sampleRate * 0.04); // 40ms pre-buffer
    if (audioCtx.audioWorklet && window.isSecureContext) startWithWorklet();
    else startWithScriptProcessor();
}

function startWithWorklet() {
    var processorCode = [
        'class WfviewAudioProcessor extends AudioWorkletProcessor {',
        '  constructor() {',
        '    super();',
        '    this.buffer = new Float32Array(sampleRate * 1.5);',
        '    this.writePos = 0; this.readPos = 0; this.buffered = 0;',
        '    this.started = false;',
        '    this.prebufferSamples = Math.floor(sampleRate * 0.04);',
        '    this.maxBuffered = Math.floor(sampleRate * 0.2);',
        '    this.port.onmessage = (e) => {',
        '      if (e.data === "flush") { this.buffered = 0; this.readPos = this.writePos; this.started = false; return; }',
        '      var samples = e.data; var len = samples.length; var bufLen = this.buffer.length;',
        '      for (var i = 0; i < len; i++) { this.buffer[this.writePos] = samples[i]; this.writePos = (this.writePos + 1) % bufLen; }',
        '      this.buffered += len; if (this.buffered > bufLen) this.buffered = bufLen;',
        '      if (this.started && this.buffered > this.maxBuffered) {',
        '        var target = Math.floor(sampleRate * 0.08); var skip = this.buffered - target;',
        '        this.readPos = (this.readPos + skip) % bufLen; this.buffered -= skip;',
        '      }',
        '    };',
        '  }',
        '  process(inputs, outputs) {',
        '    var output = outputs[0][0]; if (!output) return true;',
        '    if (!this.started && this.buffered < this.prebufferSamples) { output.fill(0); return true; }',
        '    this.started = true; var bufLen = this.buffer.length;',
        '    for (var i = 0; i < output.length; i++) {',
        '      if (this.buffered > 0) { output[i] = this.buffer[this.readPos]; this.readPos = (this.readPos + 1) % bufLen; this.buffered--; }',
        '      else { output[i] = 0; }',
        '    }',
        '    return true;',
        '  }',
        '}',
        'registerProcessor("wfview-audio-processor", WfviewAudioProcessor);'
    ].join('\n');
    var blob = new Blob([processorCode], { type: 'application/javascript' });
    var url = URL.createObjectURL(blob);
    audioCtx.audioWorklet.addModule(url).then(function() {
        URL.revokeObjectURL(url);
        audioWorkletNode = new AudioWorkletNode(audioCtx, 'wfview-audio-processor');
        audioWorkletNode.connect(audioGainNode); // Connect through gain node for muting
        audioUseWorklet = true;
        send({ cmd: 'enableAudio', value: true });
    }).catch(function(err) {
        console.warn('AudioWorklet failed:', err);
        URL.revokeObjectURL(url);
        startWithScriptProcessor();
    });
}

function startWithScriptProcessor() {
    audioScriptNode = audioCtx.createScriptProcessor(4096, 0, 1);
    audioScriptNode.onaudioprocess = function(e) {
        var output = e.outputBuffer.getChannelData(0);
        if (!audioRingStarted && audioRingBuffered < audioPrebufferSamples) { for (var i = 0; i < output.length; i++) output[i] = 0; return; }
        audioRingStarted = true; var bufLen = audioRingBuf.length;
        for (var i = 0; i < output.length; i++) {
            if (audioRingBuffered > 0) { output[i] = audioRingBuf[audioRingRead]; audioRingRead = (audioRingRead + 1) % bufLen; audioRingBuffered--; }
            else output[i] = 0;
        }
    };
    audioScriptNode.connect(audioGainNode); // Connect through gain node for muting
    audioUseWorklet = false;
    send({ cmd: 'enableAudio', value: true });
}

function stopAudio() {
    send({ cmd: 'enableAudio', value: false });
    audioEnabled = false;
    if (audioWorkletNode) { audioWorkletNode.disconnect(); audioWorkletNode = null; }
    if (audioScriptNode) { audioScriptNode.disconnect(); audioScriptNode = null; }
    if (audioGainNode) { audioGainNode.disconnect(); audioGainNode = null; }
    audioUseWorklet = false; audioRingBuf = null;
    if (audioCtx) { audioCtx.close(); audioCtx = null; }
    renderBottomBar();
    updateWarningVisibility();
    if (currentPanel === 'audiomiс') renderAudioMicOverlay();
}

// TX Audio / Mic (preserved)
function updateTxAudioAvailable(available) {
    txAudioAvailable = available;
    updateWarningVisibility();
}

function toggleMic() {
    if (!txAudioAvailable || !window.isSecureContext) return;
    if (micEnabled) { stopMic(); return; }
    startMic();
}

function startMic() {
    if (micEnabled) return;
    navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } })
    .then(function(stream) {
        micStream = stream;
        micAudioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
        var source = micAudioCtx.createMediaStreamSource(stream);
        var captureCode = [
            'class WfviewCaptureProcessor extends AudioWorkletProcessor {',
            '  constructor() { super(); }',
            '  process(inputs) {',
            '    var input = inputs[0]; if (!input || !input[0] || input[0].length === 0) return true;',
            '    var samples = input[0]; var int16 = new Int16Array(samples.length);',
            '    for (var i = 0; i < samples.length; i++) { var s = Math.max(-1, Math.min(1, samples[i])); int16[i] = s < 0 ? s * 32768 : s * 32767; }',
            '    this.port.postMessage(int16.buffer, [int16.buffer]); return true;',
            '  }',
            '}',
            'registerProcessor("wfview-capture-processor", WfviewCaptureProcessor);'
        ].join('\n');
        var blob = new Blob([captureCode], { type: 'application/javascript' });
        var url = URL.createObjectURL(blob);
        micAudioCtx.audioWorklet.addModule(url).then(function() {
            URL.revokeObjectURL(url);
            micWorkletNode = new AudioWorkletNode(micAudioCtx, 'wfview-capture-processor');
            source.connect(micWorkletNode);
            micWorkletNode.connect(micAudioCtx.destination);
            micWorkletNode.port.onmessage = function(e) {
                if (!micEnabled || !ws || ws.readyState !== WebSocket.OPEN) return;
                var pcmBuffer = e.data;
                var frame = new ArrayBuffer(6 + pcmBuffer.byteLength);
                var view = new DataView(frame);
                view.setUint8(0, 0x03); view.setUint8(1, 0x00);
                view.setUint16(2, micSeq++ & 0xFFFF, true); view.setUint16(4, 0, true);
                new Uint8Array(frame, 6).set(new Uint8Array(pcmBuffer));
                ws.send(frame);
            };
            micEnabled = true;
            send({ cmd: 'enableMic', value: true });
            renderBottomBar();
            updateWarningVisibility();
            if (currentPanel === 'audiomiс') renderAudioMicOverlay();
        }).catch(function(err) { console.error('Mic AudioWorklet failed:', err); stopMic(); });
    }).catch(function(err) { console.error('getUserMedia failed:', err); });
}

function stopMic() {
    send({ cmd: 'enableMic', value: false }); micEnabled = false;
    if (micWorkletNode) { micWorkletNode.disconnect(); micWorkletNode = null; }
    if (micStream) { micStream.getTracks().forEach(function(t) { t.stop(); }); micStream = null; }
    if (micAudioCtx) { micAudioCtx.close(); micAudioCtx = null; }
    micSeq = 0; renderBottomBar();
    updateWarningVisibility();
    if (currentPanel === 'audiomiс') renderAudioMicOverlay();
}

function handleAudioData(buffer) {
    if (!audioEnabled || isTransmitting) return;
    if (buffer.byteLength < 8) return;
    var pcmData = new Int16Array(buffer, 6);
    var floatData = new Float32Array(pcmData.length);
    for (var i = 0; i < pcmData.length; i++) floatData[i] = pcmData[i] / 32768.0;
    if (audioUseWorklet && audioWorkletNode) {
        audioWorkletNode.port.postMessage(floatData);
    } else if (audioRingBuf) {
        var len = floatData.length, bufLen = audioRingBuf.length;
        for (var i = 0; i < len; i++) { audioRingBuf[audioRingWrite] = floatData[i]; audioRingWrite = (audioRingWrite + 1) % bufLen; }
        audioRingBuffered += len; if (audioRingBuffered > bufLen) audioRingBuffered = bufLen;
        var maxBuf = Math.floor(audioSampleRate * 0.2); // 200ms max buffer
        if (audioRingStarted && audioRingBuffered > maxBuf) {
            var target = Math.floor(audioSampleRate * 0.08), skip = audioRingBuffered - target; // 80ms target
            audioRingRead = (audioRingRead + skip) % bufLen; audioRingBuffered -= skip;
        }
    }
}

function flushAudio() {
    if (audioUseWorklet && audioWorkletNode) audioWorkletNode.port.postMessage('flush');
    else if (audioRingBuf) { audioRingBuffered = 0; audioRingRead = audioRingWrite; audioRingStarted = false; }
}

// ============================================================
// SPECTRUM / WATERFALL
// ============================================================
function buildColorTable() {
    colorTable = new Array(256);
    for (var i = 0; i < 256; i++) {
        var v = i / 255; var r, g, b;
        if (v < 0.25) { r = 0; g = Math.round(255 * (v / 0.25)); b = 255; }
        else if (v < 0.5) { r = 0; g = 255; b = Math.round(255 * (1 - (v - 0.25) / 0.25)); }
        else if (v < 0.75) { r = Math.round(255 * ((v - 0.5) / 0.25)); g = 255; b = 0; }
        else { r = 255; g = Math.round(255 * (1 - (v - 0.75) / 0.25)); b = 0; }
        colorTable[i] = [r, g, b];
    }
}

function resizeCanvases() {
    var spectCanvas = document.getElementById('spectrumCanvas');
    var wfCanvas = document.getElementById('waterfallCanvas');
    var area = document.getElementById('scopeArea');
    var areaRect = area.getBoundingClientRect();
    if (areaRect.width <= 0 || areaRect.height <= 0) return;

    var spectH = Math.round(areaRect.height * 0.35);
    var wfH = Math.round(areaRect.height * 0.65);
    spectCanvas.style.height = spectH + 'px';
    wfCanvas.style.top = spectH + 'px';
    wfCanvas.style.height = wfH + 'px';
    spectCanvas.width = Math.round(areaRect.width);
    spectCanvas.height = spectH;
    wfCanvas.width = Math.round(areaRect.width);
    wfCanvas.height = wfH;
    if (spectDataLen > 0) initWaterfallBuffer(spectDataLen);
    // Redraw meter for new DPI
    drawMeter();
}

function initWaterfallBuffer(dataLen) {
    var wfCanvas = document.getElementById('waterfallCanvas');
    var h = wfCanvas.height || 200;
    wfOffCanvas = document.createElement('canvas');
    wfOffCanvas.width = dataLen; wfOffCanvas.height = h;
    wfOffCtx = wfOffCanvas.getContext('2d');
    wfImageData = wfOffCtx.createImageData(dataLen, h);
    var d = wfImageData.data;
    for (var i = 3; i < d.length; i += 4) d[i] = 255;
}

function handleBinaryMessage(buffer) {
    if (buffer.byteLength < 2) return;
    var view = new DataView(buffer);
    var msgType = view.getUint8(0);
    if (msgType === 0x02) { handleAudioData(buffer); return; }
    if (msgType !== 0x01 || buffer.byteLength < 13) return;

    spectStartFreq = view.getFloat32(4, true);
    spectEndFreq = view.getFloat32(8, true);
    spectData = new Uint8Array(buffer, 12);
    if (spectData.length !== spectDataLen) { spectDataLen = spectData.length; initWaterfallBuffer(spectDataLen); }

    // Update scope edge labels
    if (spectStartFreq > 0 && spectEndFreq > spectStartFreq) {
        var halfSpan = (spectEndFreq - spectStartFreq) / 2;
        document.getElementById('spanEdgeLeft').textContent = '-' + (halfSpan * 1000).toFixed(0);
        document.getElementById('spanEdgeRight').textContent = '+' + (halfSpan * 1000).toFixed(0);
    }

    updateWaterfallRow();
    if (!spectRenderPending) { spectRenderPending = true; requestAnimationFrame(renderScope); }
}

function updateWaterfallRow() {
    if (!wfImageData || !spectData) return;
    var w = wfImageData.width, d = wfImageData.data;
    d.copyWithin(w * 4, 0, d.length - w * 4);
    for (var i = 0; i < w; i++) {
        var amp = i < spectData.length ? spectData[i] : 0;
        var ci = Math.min(255, Math.round((amp / spectAmpMax) * 255));
        var c = colorTable[ci];
        var idx = i * 4;
        d[idx] = c[0]; d[idx+1] = c[1]; d[idx+2] = c[2]; d[idx+3] = 255;
    }
}

function renderScope() {
    spectRenderPending = false;
    if (!spectData || spectData.length === 0) return;
    drawSpectrum();
    drawWaterfall();
}

function drawSpectrum() {
    var canvas = document.getElementById('spectrumCanvas');
    var ctx = canvas.getContext('2d');
    var w = canvas.width, h = canvas.height, len = spectData.length;
    var labelH = 14, plotH = h - labelH;

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, w, h);

    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.lineWidth = 1;
    for (var gi = 1; gi < 4; gi++) {
        var gy = (plotH / 4) * gi;
        ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(w, gy); ctx.stroke();
    }

    // Fill
    ctx.beginPath(); ctx.moveTo(0, plotH);
    for (var i = 0; i < len; i++) {
        ctx.lineTo((i / (len - 1)) * w, plotH - (spectData[i] / spectAmpMax) * plotH);
    }
    ctx.lineTo(w, plotH); ctx.closePath();
    ctx.fillStyle = 'rgba(0, 200, 200, 0.08)';
    ctx.fill();

    // Line
    ctx.beginPath();
    for (var j = 0; j < len; j++) {
        var lx = (j / (len - 1)) * w, ly = plotH - (spectData[j] / spectAmpMax) * plotH;
        if (j === 0) ctx.moveTo(lx, ly); else ctx.lineTo(lx, ly);
    }
    ctx.strokeStyle = '#0bb';
    ctx.lineWidth = 1.2;
    ctx.stroke();

    // Frequency marker (IC-7300 style: white triangle + vertical line)
    if (currentFreq > 0 && spectStartFreq > 0 && spectEndFreq > spectStartFreq) {
        var freqMHz = currentFreq / 1e6;
        if (freqMHz >= spectStartFreq && freqMHz <= spectEndFreq) {
            var fxPos = ((freqMHz - spectStartFreq) / (spectEndFreq - spectStartFreq)) * w;
            // Vertical line
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(fxPos, 0); ctx.lineTo(fxPos, plotH); ctx.stroke();
            // White triangle at bottom
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(fxPos - 5, plotH);
            ctx.lineTo(fxPos + 5, plotH);
            ctx.lineTo(fxPos, plotH - 7);
            ctx.closePath();
            ctx.fill();
        }
    }

    // Freq labels
    if (spectStartFreq > 0 && spectEndFreq > spectStartFreq) {
        ctx.fillStyle = '#555';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        for (var li = 0; li <= 5; li++) {
            var frac = li / 5;
            var freq = spectStartFreq + (spectEndFreq - spectStartFreq) * frac;
            var label = freq >= 1000 ? freq.toFixed(1) : freq >= 100 ? freq.toFixed(2) : freq.toFixed(3);
            ctx.fillText(label, frac * w, plotH + 2);
        }
    }
}

function drawWaterfall() {
    if (!wfImageData || !wfOffCtx) return;
    var canvas = document.getElementById('waterfallCanvas');
    var ctx = canvas.getContext('2d');
    var w = canvas.width, h = canvas.height;
    wfOffCtx.putImageData(wfImageData, 0, 0);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(wfOffCanvas, 0, 0, w, h);

    // Frequency indicator
    if (currentFreq > 0 && spectStartFreq > 0 && spectEndFreq > spectStartFreq) {
        var freqMHz = currentFreq / 1e6;
        if (freqMHz >= spectStartFreq && freqMHz <= spectEndFreq) {
            var xPos = ((freqMHz - spectStartFreq) / (spectEndFreq - spectStartFreq)) * w;
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(xPos, 0); ctx.lineTo(xPos, h); ctx.stroke();
        }
    }
}

function scopeClick(e) {
    // Disable waterfall gestures when CW bar is active on mobile portrait
    var isMobilePortrait = window.matchMedia('(orientation: portrait) and (max-width: 600px)').matches;
    if (isMobilePortrait && !document.getElementById('cwBar').classList.contains('hidden')) return;

    if (spectStartFreq <= 0 || spectEndFreq <= spectStartFreq) return;
    var rect = e.target.getBoundingClientRect();
    var frac = (e.clientX - rect.left) / rect.width;
    var freqHz = Math.round((spectStartFreq + (spectEndFreq - spectStartFreq) * frac) * 1e6);
    // Round to nearest kHz (ending in 000 Hz)
    freqHz = Math.round(freqHz / 1000) * 1000;
    if (freqHz > 0) send({ cmd: 'setFrequency', value: freqHz });
}

function scopeWheel(e) {
    // Disable waterfall gestures when CW bar is active on mobile portrait
    var isMobilePortrait = window.matchMedia('(orientation: portrait) and (max-width: 600px)').matches;
    if (isMobilePortrait && !document.getElementById('cwBar').classList.contains('hidden')) return;

    e.preventDefault();
    if (e.deltaY < 0) tuneUp(); else tuneDown();
}

// ============================================================
// CLOCK
// ============================================================
function updateClock() {
    var now = new Date();
    document.getElementById('clock').textContent =
        String(now.getUTCHours()).padStart(2, '0') + ':' +
        String(now.getUTCMinutes()).padStart(2, '0');
}

// ============================================================
// KEYBOARD
// ============================================================
var spacebarPTTActive = false;

document.addEventListener('keydown', function(e) {
    // Don't handle shortcuts when editing macros or in input fields
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

    // Don't handle shortcuts when macro editor is open
    var macroEditor = document.getElementById('cwMacroEditor');
    if (macroEditor && macroEditor.style.display !== 'none') return;

    if (e.key === 'ArrowUp' || e.key === '+') { e.preventDefault(); tuneUp(); }
    else if (e.key === 'ArrowDown' || e.key === '-') { e.preventDefault(); tuneDown(); }
    else if (e.key === 'ArrowRight') { e.preventDefault(); tuneUpHz(); }
    else if (e.key === 'ArrowLeft') { e.preventDefault(); tuneDownHz(); }
    else if (e.key === 'Escape') { hideAllOverlays(); setPanel('default'); }
    else if (e.key === ' ' && !e.repeat) {
        e.preventDefault();
        if (!spacebarPTTActive && handlePTTPress()) {
            spacebarPTTActive = true;
            // Cancel any pending PTT release
            if (pttReleaseTimer) {
                clearTimeout(pttReleaseTimer);
                pttReleaseTimer = null;
            }
            flushAudio();
            send({ cmd: 'setPTT', value: true });
        }
    }
});

document.addEventListener('keyup', function(e) {
    // Don't handle when macro editor is open
    var macroEditor = document.getElementById('cwMacroEditor');
    if (macroEditor && macroEditor.style.display !== 'none') return;

    if (e.key === ' ' && spacebarPTTActive) {
        e.preventDefault();
        spacebarPTTActive = false;
        releasePTT(); // Use delayed release to drain TX audio
    }
});

document.getElementById('freqDisplay').addEventListener('wheel', function(e) {
    e.preventDefault();
    if (e.deltaY < 0) tuneUp(); else tuneDown();
}, { passive: false });

// Continuous touch tuning on waterfall/spectrum (vertical = kHz, horizontal = Hz)
(function() {
    var touchStartX = 0, touchStartY = 0;
    var lastTouchX = 0, lastTouchY = 0;
    var lastTuneTime = 0;
    var tuneThrottle = 50; // ms between tune commands
    var movementThreshold = 5; // minimum movement in pixels to trigger tuning
    var isTouching = false;

    function touchStart(e) {
        // Disable touch gestures when CW bar is active on mobile portrait
        var isMobilePortrait = window.matchMedia('(orientation: portrait) and (max-width: 600px)').matches;
        if (isMobilePortrait && !document.getElementById('cwBar').classList.contains('hidden')) return;

        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        lastTouchX = touchStartX;
        lastTouchY = touchStartY;
        isTouching = true;
    }

    function touchMove(e) {
        if (!isTouching) return;

        // Disable touch gestures when CW bar is active on mobile portrait
        var isMobilePortrait = window.matchMedia('(orientation: portrait) and (max-width: 600px)').matches;
        if (isMobilePortrait && !document.getElementById('cwBar').classList.contains('hidden')) return;

        var currentX = e.touches[0].clientX;
        var currentY = e.touches[0].clientY;
        var deltaX = currentX - lastTouchX;
        var deltaY = lastTouchY - currentY;

        var absDeltaX = Math.abs(deltaX);
        var absDeltaY = Math.abs(deltaY);

        // Determine if movement is primarily horizontal or vertical
        if (absDeltaX >= movementThreshold || absDeltaY >= movementThreshold) {
            var now = Date.now();
            if (now - lastTuneTime >= tuneThrottle) {
                e.preventDefault();

                // Use whichever axis has more movement
                if (absDeltaX > absDeltaY) {
                    // Horizontal swipe - Hz tuning
                    if (deltaX > 0) {
                        tuneUpHz();
                    } else {
                        tuneDownHz();
                    }
                    lastTouchX = currentX;
                } else {
                    // Vertical swipe - kHz tuning
                    if (deltaY > 0) {
                        tuneUp();
                    } else {
                        tuneDown();
                    }
                    lastTouchY = currentY;
                }
                lastTuneTime = now;
            }
        }
    }

    function touchEnd() {
        isTouching = false;
    }

    var spectCanvas = document.getElementById('spectrumCanvas');
    var wfCanvas = document.getElementById('waterfallCanvas');

    [spectCanvas, wfCanvas].forEach(function(canvas) {
        canvas.addEventListener('touchstart', touchStart, { passive: true });
        canvas.addEventListener('touchmove', touchMove, { passive: false });
        canvas.addEventListener('touchend', touchEnd, { passive: true });
        canvas.addEventListener('touchcancel', touchEnd, { passive: true });
    });
})();

document.getElementById('freqDisplay').addEventListener('click', function() {
    setPanel('freqinp');
});

// ============================================================
// MOBILE VIEWPORT FIX
// ============================================================
function setMobileViewportHeight() {
    // Set actual viewport height for mobile browsers
    var vh = window.innerHeight;
    document.documentElement.style.setProperty('--viewport-height', vh + 'px');
}

// ============================================================
// CW FUNCTIONS
// ============================================================
var cwSpeed = 20;
var cwMode = 'chars'; // chars, words, lines
var cwPendingText = '';
var cwSentText = '';
var cwCharacters = []; // Array of {char, status: 'pending'|'sending'|'sent', startTime}
var cwCharIndex = 0; // Current character being sent
var cwNextCharTime = 0; // Cumulative timing for next character
var cwUpdateTimers = []; // Track pending setTimeout IDs for cleanup

// CW Macros
var cwMacros = {}; // Macro templates for buttons
var cwEditingMacro = null; // Currently editing macro index
var cwEditMode = false; // Edit mode state

function loadCWMacros() {
    try {
        var saved = localStorage.getItem('cwMacros');
        if (saved) cwMacros = JSON.parse(saved);
    } catch(e) {}
}

function saveCWMacros() {
    try {
        localStorage.setItem('cwMacros', JSON.stringify(cwMacros));
    } catch(e) {}
}

function loadCWCallsign() {
    try {
        var saved = localStorage.getItem('cwCallsign');
        if (saved) {
            document.getElementById('cwCallInput').value = saved;
        }
    } catch(e) {}
}

function saveCWCallsign() {
    try {
        var call = document.getElementById('cwCallInput').value.trim().toUpperCase();
        localStorage.setItem('cwCallsign', call);
    } catch(e) {}
}

function substituteMacro(template) {
    var call = document.getElementById('cwCallInput').value.trim().toUpperCase();
    var qso = document.getElementById('cwQsoInput').value.trim().toUpperCase();
    return template.replace(/\[CALL\]/g, call).replace(/\[QSO\]/g, qso);
}

function toggleEditMode() {
    cwEditMode = !cwEditMode;
    var editBtn = document.getElementById('cwMacro5'); // Button 5 is EDIT/SET

    if (cwEditMode) {
        editBtn.classList.add('editing');
    } else {
        editBtn.classList.remove('editing');
    }

    // Update all macro button classes (except button 5 which is EDIT/SET)
    for (var i = 1; i <= 10; i++) {
        if (i === 5) continue; // Skip EDIT/SET button
        var btn = document.getElementById('cwMacro' + i);
        if (!btn) continue;

        if (cwEditMode) {
            btn.classList.add('editable');
        } else {
            btn.classList.remove('editable');
        }
    }
}

function updateMacroButtons() {
    for (var i = 1; i <= 10; i++) {
        if (i === 5) continue; // Skip EDIT/SET button
        var btn = document.getElementById('cwMacro' + i);
        if (!btn) continue;

        var template = cwMacros[i] || '';
        if (template) {
            btn.textContent = substituteMacro(template);
            btn.classList.remove('empty');
        } else {
            btn.textContent = 'M' + i;
            btn.classList.add('empty');
        }
    }
}

function showMacroEditor(index) {
    cwEditingMacro = index;
    document.getElementById('cwMacroText').value = cwMacros[index] || '';
    document.getElementById('cwMacroEditor').style.display = 'flex';
    // Hide CW bar while editing to prevent overlap
    document.getElementById('cwBar').style.opacity = '0';
    document.getElementById('cwBar').style.pointerEvents = 'none';
    document.getElementById('cwMacroText').focus();
}

function hideMacroEditor() {
    document.getElementById('cwMacroEditor').style.display = 'none';
    // Restore CW bar
    document.getElementById('cwBar').style.opacity = '1';
    document.getElementById('cwBar').style.pointerEvents = 'auto';
    cwEditingMacro = null;
}

// CW sidetone generator (browser-based) - uses pre-rendered buffers to avoid RX audio interference
var cwAudioContext = null;
var cwToneFreq = 600; // 600 Hz sidetone
var cwSidetoneEndTime = 0; // Track when sidetone will finish
var cwCurrentSource = null; // Track currently playing source
var cwActiveSources = []; // Track ALL active audio sources for proper cleanup
var cwRenderQueue = []; // Queue for pending sidetone renders
var cwIsRendering = false; // Track if a render is in progress
var cwCurrentRenderItem = null; // Track currently rendering item
var cwAbortCurrentRender = false; // Flag to abort current render
var cwUnmuteTimer = null; // Timer for unmuting after transmission

function initCWSidetone() {
    if (!cwAudioContext) {
        try {
            cwAudioContext = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
        } catch (e) {
            console.warn('Web Audio API not available for CW sidetone');
        }
    }
}

function muteRxAudio() {
    if (audioGainNode) {
        audioGainNode.gain.setValueAtTime(0, audioGainNode.context.currentTime);
    }
}

function unmuteRxAudio() {
    if (audioGainNode) {
        flushAudio(); // Clear any audio that accumulated while muted
        audioGainNode.gain.setValueAtTime(1, audioGainNode.context.currentTime);
    }
}

function scheduleRxUnmute(delayMs) {
    // Clear any existing unmute timer
    if (cwUnmuteTimer) {
        clearTimeout(cwUnmuteTimer);
    }
    // Schedule unmute after transmission completes
    cwUnmuteTimer = setTimeout(function() {
        unmuteRxAudio();
        cwUnmuteTimer = null;
    }, delayMs);
}

function playCWSidetone(text, startIndex) {
    if (!cwAudioContext || !text) return;

    // Mute RX audio and flush buffer when starting CW transmission
    var wasEmpty = (cwRenderQueue.length === 0 && !cwIsRendering);
    if (wasEmpty) {
        muteRxAudio();
        flushAudio(); // Clear RX audio buffer to prevent contamination
    }

    // Add to queue with character index tracking
    cwRenderQueue.push({text: text, startIndex: startIndex});
    processCWSidetoneQueue();
}

function processCWSidetoneQueue() {
    if (cwIsRendering || cwRenderQueue.length === 0) return;

    cwIsRendering = true;
    cwAbortCurrentRender = false;
    var queueItem = cwRenderQueue.shift();
    cwCurrentRenderItem = queueItem;
    var text = queueItem.text;
    var startIndex = queueItem.startIndex;

    // Morse code timing (PARIS standard)
    var dotDuration = 1200 / cwSpeed; // ms per dot
    var dashDuration = dotDuration * 3;
    var symbolGap = dotDuration;
    var charGap = dotDuration * 3;
    var wordGap = dotDuration * 7;

    // Morse code table
    var morse = {
        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',
        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
        '8': '---..', '9': '----.', '.': '.-.-.-', ',': '--..--', '?': '..--..',
        '/': '-..-.', '=': '-...-', '+': '.-.-.', ' ': ' '
    };

    text = text.toUpperCase();

    // Calculate total duration
    var totalDuration = 0;
    for (var i = 0; i < text.length; i++) {
        var char = text[i];
        var pattern = morse[char];
        if (char === ' ') {
            totalDuration += wordGap;
        } else if (pattern) {
            for (var j = 0; j < pattern.length; j++) {
                var symbol = pattern[j];
                totalDuration += (symbol === '.') ? dotDuration : dashDuration;
                totalDuration += symbolGap;
            }
            totalDuration += charGap - symbolGap;
        }
    }

    if (totalDuration === 0) {
        cwIsRendering = false;
        processCWSidetoneQueue(); // Process next in queue
        return;
    }

    // Pre-render audio buffer using OfflineAudioContext (isolated from RX audio)
    var sampleRate = cwAudioContext.sampleRate;
    var bufferLength = Math.ceil((totalDuration / 1000) * sampleRate);
    var offlineCtx = new OfflineAudioContext(1, bufferLength, sampleRate);

    var time = 0;
    for (var i = 0; i < text.length; i++) {
        var char = text[i];
        var pattern = morse[char];

        if (char === ' ') {
            time += wordGap / 1000;
        } else if (pattern) {
            for (var j = 0; j < pattern.length; j++) {
                var symbol = pattern[j];
                var duration = (symbol === '.') ? dotDuration : dashDuration;

                var osc = offlineCtx.createOscillator();
                var gain = offlineCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = cwToneFreq;
                osc.connect(gain);
                gain.connect(offlineCtx.destination);

                // Envelope to avoid clicks
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.15, time + 0.005);
                gain.gain.setValueAtTime(0.15, time + duration / 1000 - 0.005);
                gain.gain.linearRampToValueAtTime(0, time + duration / 1000);

                osc.start(time);
                osc.stop(time + duration / 1000);

                time += (duration + symbolGap) / 1000;
            }
            time += (charGap - symbolGap) / 1000;
        }
    }

    // Render and play the buffer
    offlineCtx.startRendering().then(function(renderedBuffer) {
        // Check if this render was aborted (user pressed delete)
        if (cwAbortCurrentRender) {
            console.log('[CW] Aborted rendering for deleted character');
            cwIsRendering = false;
            cwCurrentRenderItem = null;
            processCWSidetoneQueue();
            return;
        }

        // Schedule playback after previous sidetone finishes
        var startTime = Math.max(cwAudioContext.currentTime, cwSidetoneEndTime);

        var source = cwAudioContext.createBufferSource();
        source.buffer = renderedBuffer;
        source.connect(cwAudioContext.destination);

        // Track this source for cleanup
        cwActiveSources.push(source);

        // Remove from tracking when it ends naturally
        source.onended = function() {
            var idx = cwActiveSources.indexOf(source);
            if (idx !== -1) {
                cwActiveSources.splice(idx, 1);
            }
        };

        source.start(startTime);

        cwCurrentSource = source;
        cwSidetoneEndTime = startTime + renderedBuffer.duration;

        // Schedule character status updates
        var playbackStartMs = (startTime - cwAudioContext.currentTime) * 1000;
        scheduleCharacterUpdates(text, startIndex, playbackStartMs);

        // Mark rendering complete and process next in queue
        cwIsRendering = false;

        // If queue is now empty, schedule unmute after this buffer finishes
        if (cwRenderQueue.length === 0) {
            var playbackDelayMs = (cwSidetoneEndTime - cwAudioContext.currentTime) * 1000;
            scheduleRxUnmute(Math.max(0, playbackDelayMs + 100)); // +100ms buffer
        }

        processCWSidetoneQueue();
    }).catch(function(err) {
        console.warn('CW sidetone rendering failed:', err);
        cwIsRendering = false;

        // If queue is empty, unmute immediately on error
        if (cwRenderQueue.length === 0) {
            unmuteRxAudio();
        }

        processCWSidetoneQueue();
    });
}

function scheduleCharacterUpdates(text, startIndex, startDelayMs) {
    // Update specific characters starting at startIndex
    // Schedule their status updates relative to when this buffer starts playing

    var morse = {
        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',
        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
        '8': '---..', '9': '----.', '.': '.-.-.-', ',': '--..--', '?': '..--..',
        '/': '-..-.', '=': '-...-', '+': '.-.-.', ' ': ' '
    };

    var dotDuration = 1200 / cwSpeed;
    var dashDuration = dotDuration * 3;
    var symbolGap = dotDuration;
    var charGap = dotDuration * 3;
    var wordGap = dotDuration * 7;

    if (startIndex >= cwCharacters.length) return; // Invalid index

    // Get the first character's start time for relative calculation
    var firstCharStartTime = cwCharacters[startIndex].startTime;

    // Schedule updates for each character in this transmission
    for (var i = 0; i < text.length && (startIndex + i) < cwCharacters.length; i++) {
        var charObj = cwCharacters[startIndex + i];

        (function(charObj) {
            var char = charObj.char;

            // Calculate when this character starts relative to buffer start
            var charRelativeStart = charObj.startTime - firstCharStartTime;
            var actualStartTime = startDelayMs + charRelativeStart;

            // Mark as "sending" when transmission starts
            var timer1 = setTimeout(function() {
                if (charObj.status === 'pending') {
                    charObj.status = 'sending';
                    updateCWTranscript();
                }
            }, Math.max(0, actualStartTime));
            cwUpdateTimers.push(timer1);

            // Calculate character duration
            var pattern = morse[char];
            var charDuration = 0;

            if (char === ' ') {
                charDuration = wordGap;
            } else if (pattern) {
                for (var j = 0; j < pattern.length; j++) {
                    var symbol = pattern[j];
                    charDuration += (symbol === '.') ? dotDuration : dashDuration;
                    charDuration += symbolGap;
                }
                charDuration += charGap - symbolGap;
            }

            // Mark as "sent" when transmission completes
            var timer2 = setTimeout(function() {
                if (charObj.status === 'sending') {
                    charObj.status = 'sent';
                    updateCWTranscript();
                }
            }, Math.max(0, actualStartTime + charDuration));
            cwUpdateTimers.push(timer2);
        })(charObj);
    }
}

function clearCWTimers() {
    // Clear all pending character update timers
    for (var i = 0; i < cwUpdateTimers.length; i++) {
        clearTimeout(cwUpdateTimers[i]);
    }
    cwUpdateTimers = [];
}

function stopAllCWSidetone() {
    // Stop all active audio buffer sources
    for (var i = 0; i < cwActiveSources.length; i++) {
        try {
            cwActiveSources[i].stop();
        } catch(e) {
            // Source may have already stopped naturally
        }
    }
    cwActiveSources = [];
    cwCurrentSource = null;
    cwSidetoneEndTime = 0;
}

function toggleCWBar() {
    var cwBar = document.getElementById('cwBar');
    if (cwBar.classList.contains('hidden')) {
        // Show CW bar
        cwBar.classList.remove('hidden');
        document.getElementById('cwSpeedInput').value = cwSpeed;
        document.querySelectorAll('.cw-mode-btn').forEach(function(btn) {
            btn.classList.toggle('active', btn.dataset.mode === cwMode);
        });
        updateCWTranscript();
    } else {
        // Hide CW bar
        cwBar.classList.add('hidden');
    }
}

function renderCWOverlay() {
    document.getElementById('cwBar').classList.remove('hidden');
    document.getElementById('cwSpeedInput').value = cwSpeed;
    document.querySelectorAll('.cw-mode-btn').forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.mode === cwMode);
    });
    updateCWTranscript();
    // Initialize sidetone on first use
    initCWSidetone();
    // Send current speed to backend
    send({ cmd: 'setCWSpeed', wpm: cwSpeed });
    setTimeout(function() {
        document.getElementById('cwInput').focus();
    }, 100);
}

function updateCWTranscript() {
    var display = document.getElementById('cwDisplay');

    // Rebuild display from character array
    var html = '';
    for (var i = 0; i < cwCharacters.length; i++) {
        var ch = cwCharacters[i];
        var cls = 'cw-char ' + ch.status;
        html += '<span class="' + cls + '">' + ch.char + '</span>';
    }

    display.innerHTML = html;

    // Auto-scroll to show latest
    display.scrollLeft = display.scrollWidth;
}

function sendCWText(text) {
    if (!text) return;

    text = text.toUpperCase(); // Force uppercase for morse code

    // Calculate timing for each character
    var morse = {
        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
        'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
        'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
        'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
        'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',
        '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
        '8': '---..', '9': '----.', '.': '.-.-.-', ',': '--..--', '?': '..--..',
        '/': '-..-.', '=': '-...-', '+': '.-.-.', ' ': ' '
    };

    var dotDuration = 1200 / cwSpeed;
    var dashDuration = dotDuration * 3;
    var symbolGap = dotDuration;
    var charGap = dotDuration * 3;
    var wordGap = dotDuration * 7;

    // Use cumulative timing to prevent overlaps
    var currentTime = cwNextCharTime;
    var startIndex = cwCharacters.length; // Track where these characters start

    // Add characters with timing
    for (var i = 0; i < text.length; i++) {
        var char = text[i];
        var pattern = morse[char];

        cwCharacters.push({
            char: char,
            status: 'pending',
            startTime: currentTime,
            groupIndex: startIndex // Track which transmission this belongs to
        });

        if (char === ' ') {
            currentTime += wordGap;
        } else if (pattern) {
            for (var j = 0; j < pattern.length; j++) {
                var symbol = pattern[j];
                currentTime += (symbol === '.') ? dotDuration : dashDuration;
                currentTime += symbolGap;
            }
            currentTime += charGap - symbolGap;
        }
    }

    // Update next character time for cumulative tracking
    cwNextCharTime = currentTime;

    send({ cmd: 'sendCW', text: text });
    playCWSidetone(text, startIndex); // Pass the starting index
    updateCWTranscript();
}

function initCWHandlers() {
    // Speed buttons
    var speedInput = document.getElementById('cwSpeedInput');
    document.getElementById('cwSpeedDown').addEventListener('click', function() {
        cwSpeed = Math.max(10, cwSpeed - 1);
        speedInput.value = cwSpeed;
        send({ cmd: 'setCWSpeed', wpm: cwSpeed });
    });
    document.getElementById('cwSpeedUp').addEventListener('click', function() {
        cwSpeed = Math.min(35, cwSpeed + 1);
        speedInput.value = cwSpeed;
        send({ cmd: 'setCWSpeed', wpm: cwSpeed });
    });
    speedInput.addEventListener('change', function() {
        cwSpeed = Math.max(10, Math.min(35, parseInt(speedInput.value) || 20));
        speedInput.value = cwSpeed;
        send({ cmd: 'setCWSpeed', wpm: cwSpeed });
    });

    // Mode buttons
    document.querySelectorAll('.cw-mode-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
            cwMode = this.dataset.mode;
            document.querySelectorAll('.cw-mode-btn').forEach(function(b) {
                b.classList.remove('active');
            });
            this.classList.add('active');
        });
    });

    // Stop button
    document.getElementById('cwStopBtn').addEventListener('click', function() {
        send({ cmd: 'stopCW' });
        cwPendingText = '';
        // Clear queue and unmute RX audio
        cwRenderQueue = [];
        cwIsRendering = false;
        cwCharacters = [];
        cwCharIndex = 0;
        cwNextCharTime = 0;
        clearCWTimers(); // Clear all pending character update timers
        stopAllCWSidetone(); // Stop all active audio sources
        if (cwUnmuteTimer) {
            clearTimeout(cwUnmuteTimer);
            cwUnmuteTimer = null;
        }
        unmuteRxAudio();
        updateCWTranscript();
    });

    // Close button
    document.getElementById('cwCloseBtn').addEventListener('click', function() {
        document.getElementById('cwBar').classList.add('hidden');
        document.getElementById('cwInput').value = '';
        cwSentText = '';
        cwPendingText = '';
        cwCharacters = [];
        cwCharIndex = 0;
        cwNextCharTime = 0;
        // Clear sidetone queue
        cwRenderQueue = [];
        cwIsRendering = false;
        clearCWTimers(); // Clear all pending character update timers
        stopAllCWSidetone(); // Stop all active audio sources
        // Clear unmute timer and unmute RX audio immediately
        if (cwUnmuteTimer) {
            clearTimeout(cwUnmuteTimer);
            cwUnmuteTimer = null;
        }
        unmuteRxAudio();
        send({ cmd: 'stopCW' });
        setPanel('default'); // Return to default panel
        renderBottomBar();
    });

    // Input handling
    var cwInput = document.getElementById('cwInput');
    var lastValue = '';

    cwInput.addEventListener('input', function(e) {
        var currentValue = cwInput.value;

        if (currentValue.length > lastValue.length) {
            // Text was added
            var newChar = currentValue[currentValue.length - 1];

            if (cwMode === 'chars') {
                // Send immediately on each character and clear input
                sendCWText(newChar);
                cwPendingText = '';
                cwInput.value = '';
                lastValue = '';
                updateCWTranscript();
                return; // Skip normal processing
            } else if (cwMode === 'words') {
                // Check if space or newline was added (both break words)
                if (newChar === ' ' || newChar === '\n') {
                    // Find the last word (everything before the delimiter)
                    var beforeDelimiter = currentValue.substring(0, currentValue.length - 1);
                    var words = beforeDelimiter.trim().split(/[\s\n]+/);
                    if (words.length > 0) {
                        var lastWord = words[words.length - 1];
                        if (lastWord) {
                            sendCWText(lastWord + ' '); // Always use space in CW
                            cwPendingText = '';
                            cwInput.value = '';
                            lastValue = '';
                            updateCWTranscript();
                            return; // Skip normal processing
                        }
                    }
                } else {
                    cwPendingText += newChar;
                }
            } else if (cwMode === 'lines') {
                cwPendingText += newChar;
            }
        } else {
            // Text was deleted - update pending text
            if (cwMode !== 'chars') {
                var diff = lastValue.length - currentValue.length;
                cwPendingText = cwPendingText.substring(0, cwPendingText.length - diff);
            }
        }

        lastValue = currentValue;
        updateCWTranscript();
    });

    // Handle Enter key in WORDS and LINES modes
    cwInput.addEventListener('keydown', function(e) {
        // In character mode, Delete stops transmission and flushes all pending characters
        if ((e.key === 'Backspace' || e.key === 'Delete') && cwMode === 'chars') {
            // Check if there are any pending characters
            var hasPending = cwCharacters.some(function(ch) { return ch.status === 'pending'; });

            if (hasPending) {
                e.preventDefault();

                // Stop radio transmission immediately
                send({ cmd: 'stopCW' });

                // Stop all active sidetone audio
                stopAllCWSidetone();

                // Remove ALL pending characters from display
                cwCharacters = cwCharacters.filter(function(ch) {
                    return ch.status !== 'pending';
                });

                // Clear all queued audio
                cwRenderQueue = [];
                cwAbortCurrentRender = true;

                // Unmute RX audio (in case it was muted for CW)
                unmuteRxAudio();

                console.log('[CW] Transmission stopped, all pending characters flushed');
                updateCWTranscript();
            }
        }

        if (e.key === 'Enter') {
            e.preventDefault();
            var currentText = cwInput.value.trim();

            if (cwMode === 'words') {
                // In WORD mode, Enter sends the current word
                if (currentText) {
                    sendCWText(currentText + ' ');
                    cwInput.value = '';
                    cwPendingText = '';
                    lastValue = '';
                    updateCWTranscript();
                }
            } else if (cwMode === 'lines') {
                // In LINE mode, Enter sends the entire line
                if (currentText) {
                    sendCWText(currentText + ' '); // Append space at end of line
                    cwInput.value = '';
                    cwPendingText = '';
                    lastValue = '';
                    updateCWTranscript();
                }
            }
        }
    });

    // Initialize macro buttons
    loadCWMacros();
    loadCWCallsign();

    for (var i = 1; i <= 10; i++) {
        var grid = i <= 5 ? document.getElementById('cwMacroGrid1') : document.getElementById('cwMacroGrid2');
        var btn = document.createElement('button');
        btn.id = 'cwMacro' + i;

        // Button 5 (top right) is the EDIT/SET button
        if (i === 5) {
            btn.className = 'cw-macro-btn edit-set-btn';
            btn.textContent = 'EDIT/SET';
            btn.addEventListener('click', toggleEditMode);
        } else {
            btn.className = 'cw-macro-btn empty';
            btn.textContent = 'M' + i;

            // Click to edit (if in edit mode) or send (if not in edit mode)
            btn.addEventListener('click', (function(index) {
                return function() {
                    if (cwEditMode) {
                        // Edit mode - open editor
                        showMacroEditor(index);
                    } else {
                        // Normal mode - send macro
                        var template = cwMacros[index];
                        if (template) {
                            var text = substituteMacro(template);
                            if (text) sendCWText(text + ' ');
                        }
                    }
                };
            })(i));
        }

        grid.appendChild(btn);
    }

    updateMacroButtons();

    // Callsign inputs - update buttons when changed
    document.getElementById('cwCallInput').addEventListener('input', function() {
        updateMacroButtons();
        saveCWCallsign(); // Save CALL to localStorage
    });
    document.getElementById('cwQsoInput').addEventListener('input', updateMacroButtons);

    // Macro editor buttons
    document.getElementById('cwMacroSave').addEventListener('click', function() {
        var text = document.getElementById('cwMacroText').value.trim();
        if (text) {
            cwMacros[cwEditingMacro] = text;
        } else {
            delete cwMacros[cwEditingMacro];
        }
        saveCWMacros();
        updateMacroButtons();
        hideMacroEditor();
    });

    document.getElementById('cwMacroClear').addEventListener('click', function() {
        delete cwMacros[cwEditingMacro];
        saveCWMacros();
        updateMacroButtons();
        hideMacroEditor();
    });

    document.getElementById('cwMacroCancel').addEventListener('click', function() {
        hideMacroEditor();
    });

    // Force uppercase in macro editor textarea
    document.getElementById('cwMacroText').addEventListener('input', function(e) {
        var start = this.selectionStart;
        var end = this.selectionEnd;
        this.value = this.value.toUpperCase();
        this.setSelectionRange(start, end);
    });
}

// ============================================================
// INIT
// ============================================================
console.log('=== WFVIEW WEB UI v2.1.0 (2026-02-16) - Dual VFO Support ===');

setMobileViewportHeight();
buildColorTable();
initSliderTracking();
initCWHandlers();
renderBottomBar();
drawMeter();
updateClock();
setInterval(updateClock, 10000);

// Initialize scope info bar
var otherVfoElem = document.getElementById('otherVfoFreq');
if (otherVfoElem) updateOtherVfoDisplay();

document.getElementById('spectrumCanvas').addEventListener('click', scopeClick);
document.getElementById('waterfallCanvas').addEventListener('click', scopeClick);
document.getElementById('spectrumCanvas').addEventListener('wheel', scopeWheel, { passive: false });
document.getElementById('waterfallCanvas').addEventListener('wheel', scopeWheel, { passive: false });
window.addEventListener('resize', function() {
    setMobileViewportHeight();
    resizeCanvases();
});
requestAnimationFrame(resizeCanvases);

connect();
</script>
</body>
</html>
